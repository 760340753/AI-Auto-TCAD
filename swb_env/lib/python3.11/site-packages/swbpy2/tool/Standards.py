# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work  
# of Synopsys, Inc., and is fully protected under copyright and     
# trade secret laws. You may not view, use, disclose, copy, or      
# distribute this file or any information contained herein except   
# pursuant to a valid written license from Synopsys.                
# ==================================================================

"""
.. currentmodule:: swbpy2.tool.Standards
"""

import os
import signal
import subprocess
import weakref

from swbutils.common.SWBContext import SWBContext

class Standards:
    """
    Class with collection of methods to invoke
    standard applications of the SWB suite.
    """
    
    def __init__(self, wait_upon_exit=True, wait_timeout=None, standardout=subprocess.DEVNULL, standarderr=subprocess.DEVNULL):
        """
        Constructor of Standards object.
        
        :param bool wait_upon_exit: The object waits for the process completion before returning to the caller.
        :param bool wait_timeout: In case the option `wait_upon_exit` it is used, it sets the maximum amout of seconds to wait before raising a timeout exception
        :param standardout: standard output of the invoked process.
        :param standarderr: standard error of the invoked process.
        """
        
        # Reference to SWBContext
        self._ctx = SWBContext()
        
        # gcleanup process
        self._gcleanup_process = None
        
        # spp process
        self._spp_process = None

        # gsub process
        self._gsub_process = None
        
        # wait timeout process
        self._wait_upon_exit = wait_upon_exit
        self._wait_timeout = wait_timeout
        
        # default process streams
        self._standardout = standardout
        self._standarderr = standarderr
        weakref.finalize(self, self.finalize)

    def finalize(self):
        """
        Destructor of Standards object: takes care of closing the processes created.
        """

        # Null reference
        self._ctx = None
        
        # Killing running processes
        if self._gcleanup_process is not None:
            os.killpg(os.getpgid(self._gcleanup_process.pid), signal.SIGTERM)

        if self._spp_process is not None:
            os.killpg(os.getpgid(self._spp_process.pid), signal.SIGTERM)

        if self._gsub_process is not None:
            os.killpg(os.getpgid(self._gsub_process.pid), signal.SIGTERM)

    def gcleanup(self, path, verbose=False, default=False, fast=False, back=False, logFiles=False, preprocessorFiles=False, renumber=False, nodeFiles=False, setVars=False, extVars=False, resetStatus=False, nodes=[]):
        """
        SWB cleanup application and its standard arguments.
        
        :param str path: SWB project path.
        :param bool verbose: Switch to enable the verbose mode: '-verbose'.
        :param bool default: Switch to enable the default mode: '-d'.
        :param bool fast: Switch to enable the fast mode: '-fast'.
        :param bool back: Switch to enable the back mode: '-back'.
        :param bool logFiles: Switch to enable the log file mode: '-log'.
        :param bool preprocessorFiles: Switch to clean preprocessor files: '-pp'.
        :param bool renumber: Switch to renumber the nodes after the cleanup: '-ren'.
        :param bool nodeFile: Switch to enable the cleanup of node output files: '-res'.
        :param bool setVars: Switch to cleanup the variable: '-sv'.
        :param bool extVars: Switch to cleanup the extracted variables: '-xv'.
        :param bool resetStatus: Switch to reset the project status of the cleanup: '-unlock'.
        :param list nodes: List of input nodes to be cleaned: '-n'.
        :raises RuntimeError: If one instance of the same process it is already running.
        :raises ValueError: If the input SWB project path it is empty.
        
        .. Note::

           Please check with :ref:`api/swbpy2.tool:Examples` for use cases.
        """
                
        # check multi-invocation
        if self._gcleanup_process is not None and self._gcleanup_process.poll() is None:
            raise RuntimeError('Multi-invocation not supported: instance of gcleanup already running with PID: {0}'.format(self._gcleanup_process.pid))
        else:
            # process not launched or completed
            self._gcleanup_process = None
        
        # check argument
        if path is None or not path:
            raise ValueError('Path empty')
        
        # building invocation parameters
        args = list()
        
        # add binary
        args.append('gcleanup')
        
        # '-verbose' option
        if verbose:
            args.append('-verbose')
        
        # check default option
        if default:
            
            # '-d' option
            args.append('-d')
            
        else:

            # '-fast' option
            if fast:
                args.append('-fast')

            # '-back' option
            if back:
                args.append('-back')
            
            # '-log' option
            if logFiles:
                args.append('-log')
    
            # '-pp' option
            if preprocessorFiles:
                args.append('-pp')
    
            # '-renumber' option
            if renumber:
                args.append('-ren')
    
            # '-res' option
            if nodeFiles:
                args.append('-res')
    
            # '-sv' option
            if setVars:
                args.append('-sv')
    
            # '-xv' option
            if extVars:
                args.append('-xv')
    
            # '-unlock' option
            if resetStatus:
                args.append('-unlock')

            # '-n' option
            if len(nodes) > 0:
                snodes = ' '.join(str(node) for node in nodes)
                args.extend(['-n', snodes])
                
        # add project
        args.append(path)
        
        # standard invocation of the gcleanup
        self._gcleanup_process = subprocess.Popen(args, stdout=self._standardout, stderr=self._standarderr, preexec_fn=os.setsid)
        
        # wait for process termination
        if  self._wait_upon_exit:
            self._gcleanup_process.wait(self._wait_timeout)
            self._gcleanup_process = None
    
    def spp(self, path, macros=[], verbose=False, expr=None, input=False, pack=False, onlytcl=False, nodes=[]):
        """
        SWB preprocessor application and its standard arguments.
        
        :param str path: SWB project path.
        :param list macros: List of SWB macros to be evaluated.
        :param bool verbose: Switch to enable the verbose mode: '-verbose'.
        :param bool expr: Switch to enable the expression mode: '-e'.
        :param bool input: Switch to enable the generation of preprocessed files: '-i'.
        :param bool pack: Switch to do not generate empty lines during preprocessing: '-pack'.
        :param bool pack: Switch to do not generate empty lines during preprocessing: '-pack'.
        :param bool onlytcl: Switch to preprocess only Tcl block of command files.
        :raises RuntimeError: If one instance of the same process it is already running.
        :raises ValueError: If the input SWB project path it is empty.
        """
    
        # check multi-invocation
        if self._spp_process is not None and self._spp_process.poll() is None:
            raise RuntimeError('Multi-invocation not supported: instance of spp already running with PID: {0}'.format(self._spp_process.pid))
        else:
            # process not launched or completed
            self._spp_process = None
    
        # check argument
        if path is None or not path:
            raise ValueError('Path empty')
        
        # building invocation parameters
        args = list()
        
        # add binary
        args.append('spp')

        # macros
        for macro in macros:
            args.append(str(macro))
            
        # '-verbose' option
        if verbose:
            args.append('-verbose')

        # '-i[nput]' option
        if input:
            args.append('-i')

        # '-pack' option
        if pack:
            args.append('-pack')

        # '-e[xpr]' option
        if expr is not None:
            args.extend(['-e', expr])

        # '-onlytcl' option
        if onlytcl:
            args.append('-onlytcl')

        # '-n' option
        if len(nodes) > 0:
            snodes = ' '.join(str(node) for node in nodes)
            args.extend(['-n', snodes])
        
        # add project or filename
        args.append(path)
        
        # standard invocation of the spp
        self._spp_process = subprocess.Popen(args, stdout=self._standardout, stderr=self._standarderr, preexec_fn=os.setsid)

        # wait for process termination
        if  self._wait_upon_exit:
            self._spp_process.wait(self._wait_timeout)
            self._spp_process = None

    def gsub(self, path, verbose=False, expr=None, queue=None, maxExperiments=0, startTime=None, nodes=[]):
        """
        SWB scheduler application and its standard arguments.
        
        :param str path: SWB project path.
        :param bool verbose: Switch to enable the verbose mode: '-verbose'.
        :param bool expr: Switch to enable the expression mode: '-e'.
        :param str queue: Submits all the nodes to a queue: '-q'.
        :param int maxExperiments: Sefines maximum number of experiments to run concurrently: '-max'.
        :param str startTime: Defines the submission timestamp in the format: "mm/dd/yyyy hh:mm:ss AM|PM" (default: immediately).
        :param list macros: List of SWB macros to be evaluated.
        :param list nodes: List of input nodes to be cleaned: '-n'.
        :raises RuntimeError: If one instance of the same process it is already running.
        :raises ValueError: If the input SWB project path it is empty.
        """

        # check multi-invocation
        if self._gsub_process is not None and self._gsub_process.poll() is None:
            raise RuntimeError('Multi-invocation not supported: instance of gsub already running with PID: {0}'.format(self._gsub_process.pid))
        else:
            # process not launched or completed
            self._gsub_process = None

        # check argument
        if path is None or not path:
            raise ValueError('Path empty')

        # building invocation parameters
        args = list()
        
        # add binary
        args.append('gsub')

        # '-verbose' option
        if verbose:
            args.append('-verbose')

        # '-e[xpr]' option
        if expr is not None:
            args.extend(['-e', expr])
            
        # '-q' option
        if queue is not None:
            args.extend(['-q', queue])
            
        # '-max' option
        if maxExperiments > 0:
            args.extend(['-max', str(maxExperiments)])

        # '-startTime' option
        if startTime is not None:
            args.extend(['-startTime', startTime])

        # '-n' option
        if len(nodes) > 0:
            snodes = ' '.join(str(node) for node in nodes)
            args.extend(['-n', snodes])
            
        # add project or filename
        args.append(path)
        
        # standard invocation of the spp
        self._gsub_process = subprocess.Popen(args, stdout=self._standardout, stderr=self._standarderr, preexec_fn=os.setsid)

        # wait for process termination
        if  self._wait_upon_exit:
            self._gsub_process.wait(self._wait_timeout)
            self._gsub_process = None
