# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work  
# of Synopsys, Inc., and is fully protected under copyright and     
# trade secret laws. You may not view, use, disclose, copy, or      
# distribute this file or any information contained herein except   
# pursuant to a valid written license from Synopsys.                
# ==================================================================

import swbutils

"""
.. currentmodule:: swbpy2.gtree.gtree
"""

import difflib
import pathlib
import glob
import os
import re
import shutil
import time
import gc
import getpass
import socket
import weakref

import numpy as np
import pandas as pd

from swbutils.common.SWBContext import SWBContext
from swbutils.common.DBToolContext import DBToolContext
from swbutils.common.FileUtils import atomic_file_lock
from swbutils.common.Utils import cast2number, allclose, parse_pref_key, createIfNotExists, swb_metadata_db
from swbutils.common.swbutils_common import TclObject
from swbutils.common.ExtMetaData import ExtData, ParamExtData, VarExtData

from swbutils.mongo.mongomon import MongoMon
from swbutils.mongo.mongomig import MongoMig

from swbpy2.core.TreePool import TreePool
from swbpy2.core.core import SWBTree
from swbpy2.core.core import SWBScenario
from swbpy2.core.core import SWBStep
from swbpy2.core.exception.TreeException import TreeException

from swbpy2.core.core import STATE_DONE
from swbpy2.core.core import STATE_NONE
from swbpy2.core.core import STATE_VIRTUAL
from swbpy2.core.core import StepType_INVALID_STEP
from swbpy2.core.core import StepType_TOOL_STEP
from swbpy2.core.core import StepType_SPLIT_STEP
from swbpy2.core.core import extractDerivedPtr
from swbpy2.core.core import ConvertEnumToString



from enum import Enum

class Ctx_level(Enum):
    undefined = 0
    
    # standard level
    user = 3
    project = 4
    tool = 5

class Gtree:
    """
    Project simulation tree class.
    Class wrapper for :class:`swbpy2.core.core.SWBTree` core entity extended with
    utility functions to work with the SWB project context.
        
    :param str project: SWB project path.
    """

    def __init__(self, project, bridge_project = False ):
        """
        Create a new simulation tree for the given project.

        """
        
        # get absolute path
        project = os.path.abspath(project)
        
        # Reference to SWBContext
        self._ctx = SWBContext()
               
        # Reference to internal data frame
        self._df = None
        
        # Get SWBTree instance
        self._entity = TreePool().Lookup(project)
        
        #mongomon
        resp = ""
        bDBMode = swb_metadata_db()
                   
        # Check existence SWBTree instance
        if self._entity is None:
            # Mongo DB infrastructure for batch / script launch
            try:
                if bDBMode and not MongoMon().Exists(project):
                    xmlfile = self._ctx.get_preffile()
                    if xmlfile :
                        tmpDir =  parse_pref_key(xmlfile, "temp")
                    else:
                        tmpDir = None
                    mmbin = None
                    resp = MongoMon().Connect(project, '3', '1', mmbin, tmpDir)
                    if resp != "" :
                        print(resp)
            except Exception as e:
                pass
            
            # Creation of the SWBTree instance
            TreePool().New(project)
            
            # Retrieve new SWBTree instance
            self._entity = TreePool().Lookup(project)
                      
        
        # Load graph, variables and execution graph
        try:
            # Tcl interpreter
            self.mytcl = TclObject.Instance()    
            myinterp = self.mytcl.GetInterp() 
            self._entity.SetTclInterp(myinterp)
            self._entity.Load('')
            self._entity.LoadVars('')
        except Exception as e:
            pass
        
        # References to DBToolContext
        self.LoadDBToolCtx()
        
        
        if bDBMode and MongoMon().Exists(project):
            
            MongoMon().SetTree(self._entity, project)
            
            if MongoMig().ImportRequired(project, "SWB"):
                resp = self.mytcl.Evaluate('gproject::ShouldMigrateToDBInBatch %s' % project)
                print (f" Tcl Migrate Evaluate is {resp}")
                if resp == "Proceed" or resp == "" or bridge_project:
                    MongoMig().ImportMetaData(project, "SWB")
                elif resp == "Raise":
                    raise Exception("Project requires migration to DB")
        weakref.finalize(self, self.finalize)
    
        # Extended Meta Data utilities
        self.metadateref = [dict()]
        self.ExtData = ExtData(project,  self.metadateref )
        self.ParamExtData = ParamExtData(project,  self.metadateref )
        self.VarExtData = VarExtData(project,  self.metadateref )
    
    def finalize(self):
        """
        Destructor of Gtree object.
        """
        # Null reference
        self._ctx = None
        
        # Delete internal data DBToolContext
        if self._dbctx is not None:
            del(self._dbctx)
            self._dbctx = None
        
        # Delete internal data frame
        if self._df is not None:
            del(self._df)
            self._df = None

        # Delete tree
        TreePool().DeleteTree(self._entity.Project())

        # Null deleted reference
        self._entity = None

        # unsaved metadata
        self.ExtData.Save()
        
        # force gc
        try:
            gc.collect()
        except Exception as e:
            pass    
        
    def GetEntity(self):
        """
        Retrieve inner entity of the simulation tree.
        
        :return: Instance of the simulation tree.
        :rtype: `swbpy2.core.core.SWBTree`
        """
        return self._entity

    def LoadDBToolCtx(self, reload=False):
        """
        Load tool database
        
        :param bool reload: clean and reload previously loaded tool data.
        """
        
        # remove instance in case of reloading
        if reload:
            del(self._dbctx)
            self._dbctx = None
        
        # create database tool contexts
        self._dbctx = dict()
        self._dbctx[Ctx_level.user] = DBToolContext(self.Project())
        self._dbctx[Ctx_level.project] = DBToolContext(self.Project(), os.path.join(self.Project(), 'gtooldb.tcl'))
        self._dbctx[Ctx_level.tool] = dict()
        for tool in self.AllTools():
            prf = self.GetToolPreferenceFile(tool)
            if prf is not None:
                self._dbctx[Ctx_level.tool][tool] = DBToolContext(self.Project(), prf)
    
    def GetDBToolCtxItem(self, key, toolname=None):
        """
        Retrieve a value of a given key of the WB_tool array in the tool database.
        
        :param str key: Key of the WB_tool array in the tool database.
        :param str toolname: Tool name which the key belongs to.
        :return: Value stored in the hierarchy of tool database.
        :raises: KeyError if key is not found in the DBToolContext.
        """
        
        if toolname in self._dbctx[Ctx_level.tool].keys() and self._dbctx[Ctx_level.tool][toolname].check(key):
            return self._dbctx[Ctx_level.tool][toolname].get(key)
        
        if self._dbctx[Ctx_level.project].check(key):
            return self._dbctx[Ctx_level.project].get(key)
        
        if self._dbctx[Ctx_level.user].check(key):
            return self._dbctx[Ctx_level.user].get(key)
        
        raise KeyError("Key '%s' not found in DBToolContext" % key)
    
    def Project(self):
        """
        Retrieve SWB project path.
        
        :return: SWB project path of the current simulation tree.
        :rtype: str
        """
        return self._entity.Project()

    def ProjectOutputPath(self):
        """
        Retrieve SWB project output path.  The project output path can be configured to be different for the storage of node results in an hierarchical structured project.  
        For traditional projects the ProjectOutputPath will be the same as the ProjectOutputPath. 
        
        :return: SWB project output path of the current SWB project.
        :rtype: str
        """
        return self._ctx.project_output_path(self._entity.Project())
    
    def LoadTree(self):
        """
        Load given project simulation tree from the saved persistent storage into the the current :class:`swbpy2.core.core.SWBTree` object.
        """
        self._entity.Load('')

    def LoadVars(self, vtype='any'):
        """
        Load given project variables from the saved persistent storage into the current :class:`swbpy2.core.core.SWBTree` object.
        
        
        :param str vtype: Variable type.
        :raises RuntimeError: if vtype is not one of 'any', 'set', 'defined', 'extracted'
        """
        self._entity.LoadVars('', vtype)

    def LoadExecGraph(self):
        """
        Load the SWB project execution graph from the saved persistent storage (if available) with its set of execution nodes.
        """
        self._entity.LoadExecGraph('')

    def Save(self, nodes=[]):
        """
        Stores the simulation tree to persistent storage.
        
        :param list nodes: List of input nodes to save. If the list is empty, saves the whole simulation flow.
        """
        TreePool().SetCurrentTree(self._entity.Project())
        self._entity.Save('', nodes, False)
        self._entity.SetModified(False)

    def SaveVars(self):
        """
        Stores the variables to the persistent storage.
        """
        TreePool().SetCurrentTree(self._entity.Project())
        self._entity.SaveVars('')
        self._entity.SetModified(False)

    def AddPath(self, pvalues, scenario='default', toSave=False):
        """
        | Adds a new experiment to the tree. The length of the list of pvalues should be exactly the same as the number of split steps (parameters) in the tree flow.
        | If the tree already has an experiment which corresponds to the values of the list, new list will be not added as an experiment.
        
        :param list pvalues: The tuple of parameter values.
        :param str scenario: The name of a scenario that new experiment should be added to (defaults to "default").
        :param bool toSave: Save the simulation tree.
        :raises `RuntimeError`: If the specified scenario does not exist.
        :raises `RuntimeError`: If the specified pvalues list length does not match the number of parameters in the project.
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        self._entity.AddPath(pvalues, scenario, '')
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def UnfoldAllNodes(self, scenario=SWBScenario.ALL, toSave=False):
        """
        Unfold all nodes of a specific scenario.
        
        :param str scenario: Scenario where the nodes to be unfolded belong to.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.UnFoldAll(scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def FoldNode(self, node, scenario=SWBScenario.ALL, toSave=False):
        """
        Fold a node of a specific scenario.
        
        :param int node: Node to be folded.
        :param str scenario: Scenario where the node to be folded belongs to.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.FoldNode(node,scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def UnfoldNode(self, node, scenario=SWBScenario.ALL, toSave=False):
        """
        Unfold a node of a specific scenario.
        
        :param int node: Node to be folded.
        :param str scenario: Scenario where the node to be unfolded belongs to.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.UnFoldNode(node,scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
        
    def LockScenario(self, scenario=SWBScenario.ALL, toSave=False):
        """
        Lock a specific scenario.  Locks all nodes in the given scenario (or all scenarios if no scenario is provided) from preprocessing and execution.
        
        :param str scenario: Name of the scenario to lock.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.ResetLocks(scenario,True)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
        
    def UnlockScenario(self, scenario=SWBScenario.ALL, toSave=False):
        """
        Unlock a specific scenario.
        
        :param str scenario: Name of the scenario to unlock.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.ResetLocks(scenario,False)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
    
    def NewScenario(self, scenario, toSave=False):
        """
        Creates new scenario with the name specified.
        
        :param str scenario: Name of the new scenario.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: Raised if scenario already exists.
        """
        self._entity.NewScenario(scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def DeleteScenario(self, scenario, cleanup=True, toSave=False):
        """
        Delete scenario with the name specified.
        
        :param str scenario: Name of the scenario to be removed.
        :param bool cleanup: Cleans up the saved persisted data related to the scenario deleted.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: Raised if scenario does not exist.
        """
        nodesBefore = self.AllNodes()
        self._entity.RemoveScenario(scenario, cleanup)
        self._entity.SetModified(True)

        if toSave:
            self.Save()

    def DeleteParam(self, param, keepValue='', cleanup=True, toSave=False):
        """
        Delete parameter with the name specified.
        
        :param str param: Name of the parameter to be removed.
        :param keepValue: Keep the parameter value.  This specifies the simulation branches which are to be kept if the parameter is in the middle of the simulation flow.
        :param bool cleanup: Cleans up the results and files of those nodes which are deleted together with the parameter.
        :param bool toSave: Save the simulation tree.
        """
        nodesBefore = self.AllNodes()
        self._entity.RemoveParam(param, keepValue)
        self._entity.SetModified(True)

        if toSave:
            self.Save()

    def GetParamValues(self, param):
        """
        Returns the values of a specified parameter.
        
        :param str param: Name of the parameter.
        :raises `swbpy2.core.exception.TreeException`: If the specified parameter does not exist.        
        """
        step = self._entity.GetFlow().LookupSplitStep(param)
        if step is None:
            raise TreeException('Parameter with name "%s" not found' % param)

        values = []
        pvalues = step.GetParamValues()
        for val in pvalues:
            values.append(val.GetValueAsString())
            
        return values                       
    
    def ChangeParamValues(self, param, values=[], toSave=False):
        """
        Change the values of a specified parameter.
        
        :param str param: Name of the parameter.
        :param list values: Parameter values.
        :param bool toSave: Save the simulation tree.
        :raises `swbpy2.core.exception.TreeException`: If the specified parameter does not exist.
        :raises `swbpy2.core.exception.TreeException`: If the specified list of values has got a different number of elements respect to current list of values.
        """
        step = self._entity.GetFlow().LookupSplitStep(param)
        if step is None:
            raise TreeException('Parameter with name "%s" not found' % param)
        
        current_values = step.GetParamValues()
        if len(current_values) != len(values):
            raise TreeException('Error: parameter "%s" has "%d" values, new list contains "%d" value(s)' % (param, len(current_values),len(values)))
        if len(values) <= 0:
            return
        
        index = 0
        for val in current_values:
            val.SetValue(str(values[index]))
            index += 1
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def RemoveParamValues(self, param, values, scenario=SWBScenario.ALL, cleanup=True, toSave=False):
        """
        Removes list of values for a parameter of the simulation tree.
        
        :param str param: Name of the parameter.
        :param values: List of values to be removed.
        :param str scenario: Name of the scenario where the value of the parameter belongs to.
        :param bool cleanup: Cleans up the saved persisted node data of the removed parameter.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: invalid parameter name.
        :raises RuntimeError: invalid parameter value.
        :raises RuntimeError: scenario does not exist.
        
        
        """
        nodesBefore = self.AllNodes()
        self._entity.RemoveParamValues(param, values, scenario, cleanup)

        self._entity.SetModified(True)
        
        if toSave:
            self.Save()   

    def RemoveParamValue(self, param, value, scenario=SWBScenario.ALL, cleanup=True, toSave=False):
        """
        Remove a specific value for a parameter of the simulation tree.
        
        :param str param: Name of the parameter.
        :param value: Value to be removed.
        :param str scenario: Name of the scenario where the value of the parameter belongs to.
        :param bool cleanup: Cleans up the saved persisted node data of the removed parameter.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: invalid parameter name.
        :raises RuntimeError: invalid parameter value.
        :raises RuntimeError: scenario does not exist.
        
        
        """
        nodesBefore = self.AllNodes()
        self._entity.RemoveParamValue(param, str(value), scenario, cleanup)
        self._entity.SetModified(True)
        
        if toSave:
            self.Save()
        
    def SetToolLock(self, tool, scenario=SWBScenario.ALL, lock=True, toSave=False):
        """
        Set a lock flag for all the nodes belonging to a given scenario.
        
        :param str tool: Name of the tool.
        :param str scenario: Name of the scenario where the nodes should be locked or unlocked.
        :param bool lock: Value of the lock flag.
        :param bool toSave: Save the simulation tree.
        """
        nodes = list()
        steps = self.ToolSteps(tool);
        for step in steps:
            nodes += self.AllStepNodes(scenario, step)
        for node in nodes:
            self._entity.FindNodeExt(int(node)).SetLock(lock)
            
        if len(nodes) <= 0:
            return
        
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def DeleteTool(self, tool, cleanup=True, toSave=False):
        """
        Delete a specific tool.
        
        :param str tool: Name of the tool to be deleted. If the tool has parameters, they will be deleted.
        :param bool cleanup: Cleans up the save persisted node data related to the tool deleted.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: tool not in project.
        """  
        self.DeleteTool2(tool, SWBStep.DELETE , cleanup, toSave)
        
    def DeleteTool2(self, tool, shift=SWBStep.PREVIOUS, cleanup=True, toSave=False):
        """
        Delete a specific tool and shift the remaining stages right or left.  Possible shift values:
             - SWBStep.PREVIOUS - shift parameters to the previous tool in the flow.
             - SWBStep.NEXT - shift parameters to the next tool in the flow. 
             - SWBStep.DELETE - delete parameters, do not shift them.

        :param bool cleanup: Cleans up the saved persisted node data related to the tool deleted.        
        :param str tool: Name of the tool to be deleted.
        :param enum shift: What to do with parameters of the tool being deleted.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: tool not in project.
        :raises RuntimeError: shift attempted beyond project boundaries.
        """
        nodesBefore = self.AllNodes()
        relocatedNodes=[]
        for node in nodesBefore:
            if self.NodeTool(node) == tool:
                relocatedNodes.append(node)
        
        #if we don't remove parameters we cannot delete the tool
        if shift == SWBStep.DELETE:
            params = self.ToolPnames(tool)
            if params:
                for p in params:
                    self.DeleteParam(p)        
                
        self._entity.RemoveTool2(tool,shift)
        self._entity.SetModified(True)
        
        if toSave:
            self.Save()
    
    def SetToolCmdline(self, tool, cmdline, toSave=False):
        """
        Set command line option for a specific tool.
        note: python will crash if the tool does not exist.
        
        :param str tool: Name of the tool.
        :param str cmdline: Command line options to be specified for a tool.
        :param bool toSave: Save the simulation tree.
        :raises `swbpy2.core.exception.TreeException.TreeException`: raised if tool not found
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        obj = self._entity.GetFlow().LookupToolStep(tool)
        if obj is None:
            raise TreeException('Tool with name "%s" not found' % tool)
 
        obj.SetCmdLineOptions(cmdline)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def GetToolCmdline(self, tool):
        """
        Retrieve command line option for a specific tool.
        
        :param str tool: Name of the tool.
        :return: Command line options of the tool.
        :rtype: str
        :raises swbpy2.core.exception.TreeException: if tool with the given name is not found
        """
        obj = self._entity.GetFlow().LookupToolStep(tool)
        if obj is None:
            raise TreeException('Tool with name "%s" not found' % tool)
        
        return obj.GetCmdLineOptions()

    def SetToolComment(self, tool, comment, toSave=False):
        """
        Set message comment for a specific tool.
        
        :param str tool: Name of the tool.
        :param str comment: Comment message for the tool.
        :param bool toSave: Save the simulation tree.
        :raises swbpy2.core.exception.TreeException: if tool with the given name is not found
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        obj = self._entity.GetFlow().LookupToolStep(tool)
        if obj is None:
            raise TreeException('Tool with name "%s" not found' % tool)
        
        obj.SetComment(comment)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def GetToolComment(self, tool):
        """
        Retrieve comment message for a specific tool.
        
        :param str tool: Name of the tool.
        :return: Comment message of the tool.
        :rtype: str
        :raises swbpy2.core.exception.TreeException: if tool with the given name is not found
        """
        obj = self._entity.GetFlow().LookupToolStep(tool)
        if obj is None:
            raise TreeException('Tool with name "%s" not found' % tool)
        
        return obj.GetComment()

    def GetToolPreferenceFile(self, toolname):
        """
        Get the name of the tool preference file of the given tool in the flow.
        
        :param str toolname: Name of the tool.
        :return: An absolute path to the tool preference file for the specific tool.
        :rtype: str
        :raises swbpy2.core.exception.TreeException: if tool with the given name is not found
        """
        
        # retrieve tool objects
        obj = self._entity.GetFlow().LookupToolStep(toolname)
        if obj is None:
            raise TreeException('Tool with name "%s" not found' % toolname) 
        
        # tool preference file
        prffile = "%s_%s.prf" % (toolname,self.GetDBToolCtxItem('%s,acronym' % obj.GetDBTool()))
        prffile = os.path.join(self.Project(), prffile)
        
        return prffile

    def _node_status_file(self, node):
        """
        Get the name of the node status file of the given node.
        
        :param int node: Input node number.
        :return: An absolute path to the node status file for the specific node.
        :rtype: str
        """
        
        # retrieve tool objects
        toolname = self.NodeTool(node)
        obj = self._entity.GetFlow().LookupToolStep(toolname)
        stafile = "n%s_%s.sta" % (node,self.GetDBToolCtxItem('%s,acronym' % obj.GetDBTool()))
        if self._entity.ProjectMetadata().IsHierarchical():
            return os.path.join(self.ProjectOutputPath(),"results", "nodes", str(node), stafile)
        else:
            return os.path.join(self.Project(), stafile)
    
    def SetToolAttribute(self, tool, key, value):
        """
        Set the value of an attribute in the tool preference file.
        
        :param str tool: Name of the tool.
        :param str key: Tool attribute name as it appears in a tool database.
        :param str value: Value of the attribute.
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        
        # tool preference file
        prfFile = self.GetToolPreferenceFile(tool)
        
        # key entry
        entry = "WB_tool(%s,%s)" % (self.DBTool(tool),key)

        # read tool preference file
        lines = list()
        if os.path.isfile(prfFile):
           with open(prfFile) as hf:
               lines = hf.readlines()
        
        # go through settings and remove the existing one
        results = list()
        for line in lines:
            if entry not in line:
                results.append(line.strip())  
               
        # add required line
        newline = 'set %s "%s"' % (entry, value)
        results.append(newline.strip())        
        
        # rewrite file
        with open(prfFile, "w") as hfp:
            hfp.write('\n'.join(results))
        
    def GetToolAttribute(self, tool, key):
        """
        Retrieve the value of an attribute from the tool preference file.
        
        :param str tool: Name of the tool.
        :param str key: Tool attribute name as it appears in a tool database.
        :return: Value of the attribute found in the tool preference file.
        :rtype: str
        :raises swbpy2.core.exception.TreeException.TreeException: if attribute not found in tool
        """
        
        # tool preference file
        prfFile = self.GetToolPreferenceFile(tool)
        
        # key entry
        entry = "WB_tool(%s,%s)" % (self.DBTool(tool),key)

        # read tool preference file
        lines = list()
        if os.path.isfile(prfFile):
           with open(prfFile) as hf:
               lines = hf.readlines()
        
        # go through settings and find the passing line
        lineFound = None
        for line in lines:
            if entry in line:
                lineFound = line.strip()
                break  

        if lineFound:
            pos = lineFound.find(entry)
            pos = pos + len(entry)
            value = lineFound[pos:].strip()
            return value.strip('"')
        else:
            raise TreeException('Attribute "%s" not found in tool preference file "%s"' % (key,prfFile))
        
    
    def VarValue(self, node, varname, type='any', cast=False, loadVars=True):
        """
        Gets the value of the specified variable for the given node.
        
        `The value is being looking with the folowing priority:`
            - parameter 'varname' is specified for the node
            - extracted variable 'varname' is specified for the node (keep in mind "type")
            - #set or #seth value is specified for the node (keep in mind "type")
            - defined variable 'varname' is specified for the node (keep in mind "type")
            - global variable 'varname' exists in the tree. It can contain a formula, that's why it is evaluated first with GTree::ParseExpression.
        
        If there is no value for the specified node, the same algorithm is used for the parent node etc. until
        the root node will be reached.
        
        :param int node: Gets the variable value at this node; a node inherits variables of all of its descendants, thus the variable could have been set or extracted at any node along the path from the given node to the root of the tree.
        :param str varname: The name of the variable to look for.  This could also be a parameter.
        :param str type: Variable type, can be: [ any | set | extracted | defined | not_set | not_extracted ].
        :param bool cast: Force cast of output variable value.
        :param bool loadVars: Force reloading variables before retrieving the value.
        :return: A tuple containing value returned, the type or timestamp of the value and the node where the value set.  If the varname does not exist a tuple of three empty values will be required.
        :rtype: tuple
        :raises RuntimeError: if node does not exist.
        
        """
        if loadVars:
            self._entity.LoadVars('', type)
        
        value, date, node = self._entity.VarValueTuple(node, varname, type)
        if cast:
            try:
                value = int(value)
            except ValueError:
                try:
                    value = float(value)
                except ValueError:
                    pass
    
        return value, date, node
    
    def NodePval(self, node, pname='', cast=False):
        """
        Returns the value of parameter 'pname' that the node 'node' have in the tree.
        
        :param int node: Input node number.
        :param str pname: The name of the parameter.
        :param bool cast: If is set to True, tries to cast the return value to numerical type (int or float).
        :raises RuntimeError: if node does not exist.
        """
        if pname is not None and pname:
            obj = self._entity.NodePval(node, pname)
        else:
            obj = self._entity.FindNodeExt(int(node)).Pvalue()
        value = obj.GetValueAsString() if obj is not None else ''
        if cast:
            try:
                value = int(value)
            except ValueError:
                try:
                    value = float(value)
                except ValueError:
                    pass

        return value

    def NodePname(self, node):
        """
        Returns the name of the parameter in the tree which the given node belongs to. If the node doesn?t belong to a parameteric step, returns an empty string.
        
        :param int node: Input node number.
        :raises RuntimeError: if node does not exist.
        """
        step = self._entity.GetFlow().GetStep(self._entity.FindNodeExt(int(node)).Step())
        if (step.GetStepType() == StepType_SPLIT_STEP):
            return extractDerivedPtr(step).GetPname()
        
        return str()

    def ChangeNodeValue(self, node, value, version=2, toSave=False):
        """       
        Changes the parameter value of the node. It will fail if there are other nodes in the same step with the same value, as it would require merging and re-parenting. In this case use version = 2.
        
        :param int node: Input node number.
        :param value: New value to apply.
        :param int version: Version number of the algorithm.
        :param bool toSave: Save the simulation tree.
        """
        node = self._entity.FindNodeExt(int(node))
        if version <= 1:
            node = self._entity.ChangeNodeValue(node, value)
        else:
            node = self._entity.ChangeNodeValue2(node, value)
        
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def AllTools(self):
        """
        Returns a list of all tool names in the flow order.
        
        :return: List of tool names.
        :rtype: list
        """
        return self._entity.AllTools()

    def AllScenarios(self):
        """
        Returns a list of all scenarios.
        
        :return: List of scenario names.
        :rtype: list
        """
        return self._entity.AllScenarios_str()
    
    def AllPnames(self):
        """
        Returns the list of all parameter names in the tree flow.
        
        :return: List of parameter names.
        :rtype: list
        """
        return self._entity.AllPnames()

    def ToolPnames(self, toolname):
        """       
        Returns the list of parameter names of the given tool.
        
        :param str toolname: Name of the tool.
        :return: List of parameter names.
        :rtype: list
        """
        return self._entity.ToolPnames(toolname)

    def AllVarNames(self):
        """
        Returns a list of all variable names.
        
        :return: List of parameter names.
        :rtype: list
        """
        return self._entity.AllVarNames()

    def AllNodes(self, scenario=SWBScenario.ALL):
        """
        Returns the list of all nodes of the specified scenario.
        
        :param str scenario: Name of the scenario.  If not specified, then nodes from all scenarios will be returned.
        :return: List of parameter names.
        :rtype: list
        """
        return self._entity.AllNodes(scenario)

    def AllLeafNodes(self, scenario=SWBScenario.ALL, showpruned=True, fold=False):
        """
        Returns the list of all tree leaf nodes which belong to specified scenario.  Leaf nodes are the last nodes in an experiment path of nodes.
        
        :param str scenario: Name of the scenario.  If not specified, then left nodes from all scenarios willbe returned.
        :param bool showpruned: Include pruned nodes.  If not specified, then pruned nodes will be included.
        :param bool fold: Include fold nodes.
        :return: List of leaf nodes.
        :rtype: list
        """
        return self._entity.AllLeafNodes(scenario, showpruned, fold)

    def NExperiments(self, **kwargs):
        """
        Returns the number of experiments.
        
        :param ``**kwargs``: Arguments to specify matching experiments: scenario, showpruned, fold. For the description of the parameters, see the method :func:`AllLeafNodes <swbpy2.gtree.gtree.Gtree.AllLeafNodes>`.
        :return: Number of experiments.
        :rtype: int
        """
        return len(self.AllLeafNodes(**kwargs))

    def NodePath(self, node):
        """
        Returns the list of ancestor nodes of the specified node in ascending order. The list contains all ancestors from the root node to the immediate ancestor.
        
        :note: For obtaining the nodes in descending order see NodeAncestors
        :param int node: Input node.
        :return: Ancestor nodes.
        :rtype: list
        :raises RuntimeError: if node does not exist.
        """
        return self._entity.NodePath(node)

    def NSteps(self):
        """
        Returns the number of steps in the flow.
        
        :return: Number of steps.
        :rtype: int
        """
        return self._entity.NbSteps()

    def NodeAncestors(self, node):
        """
        Returns the list of ancestor nodes of the specified node in descending order. The list contains all ancestors from the immediate one to the root node of the tree.

        :note: For obtaining the nodes in ascending order see NodePath
        :param int node: Input node.
        :return: Ancestor nodes.
        :rtype: list
        :raises RuntimeError: if node does not exist.
        """
        return self._entity.NodeAncestors(node)

    def NodeChildren(self, node, scenario=SWBScenario.ALL):
        """
        Returns the list of direct descendant nodes of the specified node, which belongs to the specified scenario. If scenario is NULL, the scenario 'all' will be used.
        
        :param int node: Input node.
        :param str scenario: Name of the scenario.
        :return: List of children nodes.
        :rtype: list
        :raises RuntimeError: if node does not exist.
        """
        return self._entity.NodeChildren(node, scenario)
    
    def NodeData(self, node, detect_virtual = False):
        """
        Returns a dictionary with the node data:\n
            - node:         Input node number (the same as the input node)\n
            - node_path:    Path to the directory with node files\n
            - status:       Node status\n
            - host_name:    If defined, specifies execution host\n
            - start:        If defined, specifies the time the node started (timestamp)\n
            - stop:         If defined, specifies the time the execution stopped (timestamp)\n
            - elapsed time: If defined, specifies the execution time in seconds\n
            - scheduler:    If defined, specifies the scheduler the node has been submitted to\n
            - job_id:       If defined, specifies the job ID on the target scheduler\n 

        :param int node: Input node.
        :param bool detect_virtual: If set to True, it will return status 'virtual' for a virtual node, otherwise it will return status 'none' for virtual node.        
        :return: Dictionary with node data.
        :rtype: dict
        """
        data = dict()
        data["node_path"] = self.Project()
        if (detect_virtual and self.NodeIsVirtual(node)):
            data["status"] = ConvertEnumToString(STATE_VIRTUAL)
            return data
        else:
            data["status"] = ConvertEnumToString(STATE_NONE)
        data["node"] = node
        if self._entity.ProjectMetadata().IsHierarchical():
            data["node_path"] = os.path.join(self.ProjectOutputPath(),"results", "nodes", str(node))
        if swb_metadata_db():
            db_data = MongoMon().GetSwbOperations( self.Project() ).CollectNodeStatusMetaData(node)
            if len(db_data) > 0:
                data["host_name"] = db_data["host"]
                data["stop"] = db_data["timestamp"]
                data["status"] = db_data["status"]
                if "exectime" in db_data and isinstance(db_data["exectime"], str) and db_data["exectime"].isnumeric():
                    data["elapsed_time"] = db_data["exectime"]
                    data["start"] = (int)(data["stop"]) - (int)(data["elapsed_time"] )
                if type(db_data["pid"]) is dict:
                    key = list(db_data["pid"].keys())[0]
                    data["scheduler"] = key
                    data["job_id"] = db_data["pid"][key]
        else:
            # read node status file
            stafile = self._node_status_file(node)
            if os.path.isfile(stafile):
                hf = open(stafile,"r")
                line1 = hf.readline()
                line2 = hf.readline()
                hf.close()
                parts = line1.split("|")
                data["stop"] = int(parts[1])
                data["status"] = parts[2]
                data["host_name"] = parts[3]
                et = parts[4].strip()
                if et.isnumeric():
                    data["elapsed_time"] = int(et)
                    data["start"] = data["stop"] - data["elapsed_time"] 
                parts2 = line2.split(":")
                if len(parts2) == 2:
                    data["scheduler"] = parts2[0].strip()
                    data["job_id"] = parts2[1].strip()
        return data

    def NodeStatus(self, node, detect_virtual = False, detect_pruned = True ):
        """
        Returns the status of the node. The status return values will be one of the following: 'none', 'queued', 'ready', 'pending', 'running', 'done', 'failed', 'aborted'. 
                For virtual and pruned nodes the status can take value 'virtual' or 'pruned' depending on the parameters.
        
        :param int node: Input node.
        :param bool detect_virtual: If set to True, it will return status 'virtual' for a virtual node, otherwise it will return status 'none' for virtual node.
        :param bool detect_pruned: If set to True, it will return status 'pruned' for a node with pruned attribute set, otherwise it will return the status of the node. 
        :return: Node status.  
        :rtype: str
        :raises RuntimeError: node does not exist.
        """        

        #check pruned attribute overrides output state
        if detect_pruned:
            swbnode = self._entity.FindNodeExt(int(node))
            strstate = swbnode.StateAsString()
            if strstate == "pruned":
                return strstate

        node_data = self.NodeData(node, detect_virtual)
        return node_data["status"]

    def ChangeNodeStatus(self, node, status):
        """
        Change the node status in its internal data and in the corresponding saved persistent storage of the project.
        
        :param int node: Input node.
        :param str status: New node status.  Status should be one of the following: none, queued, ready, pending, running, done, failed, aborted
        :return: True if operation successful, false otherwise.
        :rtype: bool

        Raises ValueError: if attempt to "prune"
        """

        if status == "pruned":
            raise ValueError(f"Pruned not a valid output state, use PruneNode(nkey)")


        if swb_metadata_db():
            node_status_dict = dict()
            node_status_dict["status"] = status
            node_status_dict["timestamp"] = int(time.time())
            node_status_dict["host"] = socket.getfqdn()
            node_status_dict["toolExt"] = "pyt"
            node_status_dict["exectime"] = 0
            node_status_dict["pid"] = "localhost:" + os.getpid()
            MongoMon().GetSwbOperations( self.Project() ).UpdateNodeStatusMetaData(node, node_status_dict)
        else:
            # check node virtual
            if self.NodeIsVirtual(node):
                return False
            
            # check current node status
            if status == self.NodeStatus(node):
                return False
            
            # update node status
            node = self._entity.FindNodeExt(int(node))
            node.SetState(status)

            # update node status file
            filename_status = self._node_status_file(node.Nkey())
            fpath = os.path.dirname(filename_status)
            if not os.path.exists(fpath):
                os.makedirs(fpath)
                
            hf = open(filename_status,"w")
            line = "     |%d|%s|%s|reset by %s\n--" % (int(time.time()),status,socket.getfqdn(),getpass.getuser())
            hf.write(line)
            hf.close()
        return True

    def NodeReconstructResults(self, node, trials=3, delay=3):
        """
        Retrieve node simulation results directly from the node output file.
        
        :param NKEY node: Input node.
        :param int trials: Number of attempts to wait for the node output file.
        :param int delay: Number of seconds between attempts.
        :return: Reconstructed results of the node.
        :rtype: dict
        :raises RuntimeError: node does not exist.
        """

        if swb_metadata_db():
            return

        node = self._entity.FindNodeExt(int(node)).Nkey()
        results = dict()
        # gtree::ExtractDOE
        reg_exp = r"DOE:[\s]*([a-zA-Z_][a-zA-Z0-9/_]*)(.*)$"
        pattern = "n" + str(node) + "_*.out"
        if self._entity.ProjectMetadata().IsHierarchical():
            pattern = os.path.join("results", "nodes", str(node), pattern)
        fitfiles = glob.glob(os.path.join(self.ProjectOutputPath(), pattern))
        if not fitfiles:
            for i in range(trials-1):
                time.sleep(delay)
                fitfiles = glob.glob(os.path.join(self.ProjectOutputPath(), pattern))
                if fitfiles:
                    break
                            
        fitfiles = glob.glob(os.path.join(self.ProjectOutputPath(), pattern))
        if len(fitfiles) > 0 and os.path.isfile(fitfiles[0]):
            hf = open(fitfiles[0],"r")
            lines = hf.readlines()
            hf.close()
            for line in lines:
                matchObj = re.match(reg_exp,line,re.M)
                if matchObj:
                    key = matchObj.group(1)
                    val = matchObj.group(2)
                    results[key] = val.strip()
        return results

    def NodeTool(self, node):
        """
        Retrieve the tool name of the node.
        
        :param int node: Input node.
        :return: The name of the tool of the given node.
        :rtype: string
        :raises RuntimeError: node does not exist.
        """
        return self._entity.NodeTool(node)

    def SetNodeLock(self, node, lock=True, toSave=False):
        """
        Sets a lock flag of the given node.
        
        :param int node: Input node.
        :param bool lock: Lock or unlock the given flag.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: node does not exist.
        """
        self._entity.FindNodeExt(int(node)).SetLock(lock)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def PruneNode(self, node, scenario=SWBScenario.ALL, toSave=False):
        """
        Set the given node to the pruned state.
        
        :param int node: Input node.
        :param str scenario: Name of the scenario, ( no longer needed ).
        :param bool toSave: Save the simulation tree.
        :raises AttributeError: if node does not exist.
        :raises AttributeError: if scenario does not exist.
        """

        # scenario is no longer used in pruning
        self._entity.PruneNode(node)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def UnpruneNode(self, node, scenario=SWBScenario.ALL, toSave=False):
        """
        Unset the prune flag of the given node.
        
        :param int node: Input node.
        :param str scenario: Name of the scenario, (no longer needed).
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: node does not exist.
        """
        # scenario is no longer used in pruning
        self._entity.UnPruneNode(node)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def NodeExists(self, node):
        """
        Check if the given node exists.
        
        :param int node: Input node.
        :return: Result of the check.
        :rtype: bool
        """
        return self._entity.NodeExists(node)

    def NodeIsLocked(self, node):
        """
        Returns whether a node is locked.
        
        :param int node: Input node.
        :return: Result of the check.
        :rtype: bool
        :raises: RuntimeException if node does not exist.
        """
        return self._entity.FindNodeExt(int(node)).IsLocked()

    def NodeIsVirtual(self, node):
        """
        Returns whether a node is virtual.
        
        :param int node: Input node.
        :return: Result of the check.
        :rtype: bool
        :raises: RuntimeException if node does not exist.
        """

        n = int(node)
        nstep = self._entity.FindNodeExt(n).Step()
        isvirtual = self._entity.GetFlow().StepIsVirtual(nstep)
        isjob = False
        if isvirtual:
            if swb_metadata_db():
                execNodeData = MongoMon().GetSwbOperations( self.Project() ).CollectExecNodeMetaData( node )
                if execNodeData:
                    isjob = True
                elif MongoMon().GetSwbOperations( self.Project() ).IsExecNodeDependency( node ):
                    isjob = True
            else:
                path = self.Project() + '/gexec.cmd'
                if os.path.isfile(path):
                    gexecFile = open(path,'r')
                    lines = gexecFile.readlines()
                    for line in lines:
                        lineItems = line.split()
                        if 'job' in lineItems:
                            if lineItems[1] == str(n):
                                isjob = True
                                break     
                    if not isjob and re.search(f"\"{node} | {node} | {node}\"|\"{node}\"", str(lines) ) :
                        isjob = True

        return isvirtual and not isjob

    def GetNodeDictionary(self, node, type='any'):
        """
        Return a dictionary with an aggregated set of node information. The dictionary includes the parameter values, variable values, tool label and tool name of the given node.
        
        :param int node: Input node.
        :param str type: Specifies a type of variable values defined on the node, which are to include into the dictionary. Can be any of the following: any, set, extracted, defined, not_set, not_extracted.
        :return: Aggregated set of node information.
        :rtype: dict
        :raises RuntimeError:: Raised if node does not exist.
        """
        self._entity.LoadVars('', type)
        pnames = self.AllPnames()
        vnames = self.AllVarNames()
        node_dict = dict()
        for p in pnames:
            node_dict[p] = self.NodePval(node, p, cast=True)
        for v in vnames:
            node_dict[v], date, vnode = self.VarValue(node, v, type, cast=True, loadVars=False)
        node_dict["tool_label"] = self.NodeTool(node)
        node_dict["tool_name"] = node_dict["tool_label"]
        return node_dict

    def Query(self, expr):
        """
        Query the internal data structures.
        
        :param str expr: Query expression.
        :return: Query result.
        :rtype: dict
        """
        # refresh internal _df representation
        self._update_representation()

        return self._df.query(expr)

    def FindExperiment(self, pvalues):
        """
        Method to retrieve experiments using set of values to select them.
        
        :param list pvalues: Input values.
        :return: Query result.
        :rtype: dict
        :raises KeyError: If the values provided does not match any experiments.
        """
        # refresh internal _df representation
        self._update_representation()
        
        try:
            idx = self._df.index.get_loc(pvalues)
        except KeyError:
            # Index not found. Try with isclose
            idx = 0
            for index, row in self._df.iterrows():
                if allclose(index, pvalues):
                    return self._df.iloc[idx]["leaf_node"]
                idx += 1
            raise KeyError(f"Experiment with parameters {pvalues} not found.")
        else:
            return self._df.iloc[idx]["leaf_node"]

    def _update_representation(self):
        """
        Method to update internal data structures.
        """
        self._entity.LoadVars('')
        pnames = self.AllPnames()
        variables = self.AllVarNames()
        leaf_nodes = self.AllLeafNodes()
        pvalues = list()
        values = dict()
        for node in leaf_nodes:            
            nodepvalues = self.NodePvalues(node)
            if nodepvalues is None or len(nodepvalues) == 0:
                nodepvalues = tuple("--" for pname in pnames)
            else:
                nodepvalues = tuple(cast2number(pvalue) for pvalue in nodepvalues)
            pvalues.append(nodepvalues)
        for v in variables:
            values[v] = list()
            for node in leaf_nodes:
                value, date, node = self.VarValue(node, v, cast=True, loadVars=False)
                values[v].append(value)
        values["leaf_node"] = leaf_nodes
        scenarios = list()
        for n in leaf_nodes:
            scenarios.append(self.NodeScenarios(n))
        values["scenarios"] = scenarios
        if pnames:      
            idx = pd.MultiIndex.from_tuples(pvalues, names=pnames)
        else:
            idx = None
        if self._df is not None:
            del(self._df)
            self._df = None
        self._df = pd.DataFrame(values, index=idx)
        #gc.collect()

    
    def DeclareVariable(self, varname, defvalue=str(), refvarname=str(), after=False, toSave=False):
        """
        Method to declare a new SWB Global variable. This variable will appear in the Variables pad of the project flow in SWB GUI.
        This method is equivalent to adding a variable from the Variables menu in the SWB GUI application.
        
        :param str varname: New variable name.
        :param str defvalue: Default value.
        :param str refvarname: Reference variable name used for inserting the new variable.
        :param bool after: Insert the new variable before or after the reference variable.
        :param bool toSave: Save the simulation tree.
        """
        self._entity.DeclareVariable(varname, defvalue, refvarname, after)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def DeleteVariable(self, varname, node=0, toSave=False):
        """
        Delete a given variable on the specified node.  Note, this method does not delete global variables. 
        
        :param str varname: New variable name.
        :param int node: Node where the variable should be deleted from.  This must be set to a valid node value.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: node not valid.
        """
        node = self._entity.FindNodeExt(int(node))
        if node:
            self._entity.DeleteVariableFromNode(node.Nkey(), varname)
        else:
            self._entity.DeleteVariable(varname)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def AddDefinedVar(self, node, varname, value, toSave=False):
        """
        Add defined variable to a node.
        
        :param int node: Node where the defined variable should be added to.
        :param str varname: New or existing variable name.
        :param value: Value of the variable.
        :param bool toSave: Save the simulation tree.
        :raises: RuntimeException node does not exist.
        """
        self._entity.AddDefinedVar(node, varname, value)
        self._entity.SetModified(True)
        if toSave:
            self.SaveVars()

    def AddVar(self, node, varname, value, hidden=False, toSave=False):
        """
        Adds a preprocessing variable.  See the Senaurus Workbench User Guide section about the preprocessing variable commands of #set and #seth.
        There is no equivalent operation within the SWB GUI of this method.
        
        :param int node: Node where the preprocessed variable should be added to.
        :param str varname: Variable name.
        :param str value: Value of the variable.
        :param bool hidden: Set the variable hidden.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: node does not exist.
        """
        self._entity.AddVar(node, varname, value, hidden)
        self._entity.SetModified(True)
        if toSave:
            self.SaveVars()
    
    def AddXVar(self, node, varname, xvalue, date, toSave=False):
        """
        Add extracted variable. Usually, this is a value extracted from the node output file after simulation completes. There is no equivalent operation within the SWB GUI of this method.
        
        :param int node: Node of the variable.
        :param str varname: Variable name.
        :param str xvalue: Value of the extracted variable.
        :param int date: timestamp 
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: node does not exist.
        """
        self._entity.AddXVar(node, varname,  xvalue, date)
        self._entity.SetModified(True)
        if toSave:
            self.SaveVars()
    
    def NodeVariables(self, node, type='any'):
        """
        Retrieve the list of variables defined on a given node.
        Possible values for type are:
        any, set, defined, extracted, not_set, not_extracted
        
        :param int node: Node of the variable.
        :param str type: Type of variable to be retrieve. 
        :return: List of node variables.
        :rtype: list
        :raises RuntimeError: node does not exist.
        """
        return self._entity.NodeVarNames(node, type)

    def AddTool(self, tool, dbtool, step=StepType_INVALID_STEP, toSave=False):
        """
        Adds a tool of type dbtool at the given step.
        
        :param str tool: Name of the tool (tool label).
        :param str dbtool: Database name of the tool (tool name).
        :param int step: Step where the tool should be inserted to  (0: at the beginning of the flow, -1: at the end of the flow).
        :param bool toSave: Save the simulation tree.
        :raises `runtimeError`: tool is null or empty.
        :raises `runtimeError`: dbtool is null or empty.
        :raises `runtimeError`: tool already exists.
        :raises `runtimeError`: step invalid.        
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        nbSteps = self.NSteps()
        if step < 0 or step > nbSteps:
            step = nbSteps
        self._entity.AddTool(tool, dbtool, step)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def AddParam(self, param, defValue, step=StepType_INVALID_STEP, toSave=False):
        """
        Add a parameter to the simulation tree.
        
        :param str param: Name of the parameter.
        :param defValue: Default value.
        :param int step: Flow step where the tool should be inserted to.
        :param bool toSave: Save the simulation tree.
        
        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """
        nbSteps = self.NSteps()
        if step < 0 or step > nbSteps:
            step = nbSteps
        self._entity.AddParam(param, defValue, step)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def CreateDefaultScenario(self, scenario=SWBScenario.ALL, toSave=False):
        """
        Creates a default scenario. It is required when creating a new project.
        
        :param str scenario: Name of the scenario.
        :param bool toSave: Save the simulation tree.
        """
        if scenario == SWBScenario.ALL:
            self._entity.CreateDefaultScenario('default')
        else:
            self._entity.CreateDefaultScenario(scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
    
    def AddNodesToScenario(self, nodes, scenario, toSave=False):
        """
        Add nodes to a given scenario.  The list must contain all the nodes of all the experiments to be added.
        Lists containing nodes which form incomplete experiments will not be added.  
              
        :param list nodes: Nodes.
        :param str scenario: Name of the scenario.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: if one of the nodes in the nodes list does not exist.
        :raises RuntimeError: if scenario does not exist
        """
        self._entity.AddNodesToScenario(nodes, scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()
            
    def RemoveNodesFromScenario(self, nodes, scenario, toSave=False):
        """
        Remove nodes from scenario. The list must contain all the nodes of all the experiments to be removed. 
        Lists containing nodes which form incomplete experiments will not be removed. 
        
        :param list nodes: Nodes to be removed.
        :param str scenario: Name of the scenario.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: if a node in the nodes do not exist
        :raises RuntimeError: if scenario does not exist
        """
        self._entity.RemNodesFromScenario(nodes, scenario)
        self._entity.SetModified(True)
        if toSave:
            self.Save()

    def DBTool(self, toolname):
        """
        Retrieve the database name (tool name) of the given tool (tool label).
        
        :param str toolname: Name of the tool.
        :raises: AttributeError if project does not contain a tool with toolname
        """
        step = self._entity.GetFlow().LookupToolStep(toolname)
        dbtool = step.GetDBTool()
        if not dbtool or dbtool == '':
            dbtool = step.GetTool()
        return dbtool

    def PnameStep(self, param):
        """
        Retrieve the step where the given parameter is located.  If the param provided does not exist, the last step is returned.
        
        :param str param: Name of the parameter.
        :param bool toSave: Save the simulation tree.
        :return: The parameter step.
        :rtype: int
        """
        return self._entity.GetFlow().Index(param)

    def AllStepNodes(self, scenario=SWBScenario.ALL, step=StepType_INVALID_STEP):
        """
        Retrieve all the nodes of a given step.  
        
        :param str scenario: Name of the scenario.  If not provided then the step nodes for all scenarios will be returned.
        :param int step: Input step.  If the step is out of range or not provided, then the nodes of the last step will be returned.
        :return: Nodes of the step.
        :rtype: list
        """        
        nbSteps = self.NSteps()
        if step < 0 or step >= nbSteps:
            step = nbSteps - 1
        return self._entity.AllStepNodes(step, scenario)

    def NodePvalues(self, node):
        """
        Retrieve the list of parameter values of the given node. The values follow the order of the parameters in the flow.
        
        :param int node: Input node.
        :return: Values of the node.
        :rtype: list
        :raises RuntimeError: node does not exist.
        """ 
        return self._entity.NodePvalues_str(node)

    def NodeScenarios(self, node):
        """
        Retrieve all the scenarios of a given node.
        
        :param int node: Input node.
        :return: Scenarios where the given node is added.
        :rtype: tuple
        :raises RuntimeError: node does not exist.
        """ 
        return self._entity.NodeScenarios_str(node)

    def PdefaultValue(self, param):
        """
        Retrieve the default value of a given parameter.
        
        :param str param: Parameter name.
        :return: The value of the parameter.
        :raises: AttributeError if param does not exist.
        """
        return self._entity.GetFlow().LookupSplitStep(param).GetDefValue()

    def ToolStep(self, tool):
        """
        Return the step where a specific tool belongs to.
        
        :param str tool: Tool name.
        :return: Left most step id of the tool provided.
        :rtype: int
        :raises: IndexError if tool does not exist.
        """
        steps = self.ToolSteps(tool);
        return steps[0]

    def ToolSteps(self, tool):
        """
        Returns a list of step IDs associated with the given tool.  If the tool name is not found in the project then an empty list is returned.
        
        :param str tool: Tool name.
        :return: list of step ids of the given tool.
        :rtype: list
        """
        steps = self._entity.ToolSteps(tool);
        return [int(s) for s in steps]

    def Path(self, pvalues):
        """
        Returns either the nodes which matches the given nodes in pvalues or a nodes up to the point where the list diverges from current
        set of experiments.  In which case a non-existent zero node is entered at the point of divergence and no more list entries are added.
        
        :param list pvalues: Parameter values.
        :return: Nodes which correspond to the parameter values in in pvalues or nodes up to point of divergence in the case where pvalues does not match an experiment.
        :rtype: list
        """
        return self._entity.Path(pvalues)
    
    def RemovePath(self, values, scenario=SWBScenario.ALL, toSave=False):
        """
        Remove a given experiment, made of the list of its values, from a scenario.
        
        :param list pvalues: Parameter values.
        :param str scenario: Input scenario.
        :param bool toSave: Save the simulation tree.
        :raises RuntimeError: invalid path - wrong number of values or incorrect values
        :raises RuntimeError: invalid scenario
        """
        nodesBefore = self.AllNodes()
        self._entity.RemovePath(values, scenario, True)
        self._entity.SetModified(True)
        
        if toSave:
            self.Save()

    def SetPdefaultValue(self, param, defaultValue):
        """
        Set the default value of a given parameter.
        Only renumbers the nodes without renaming node files.
        
        :param str param: Input parameter.
        :param defaultValue: New default value.
        :raises `swbpy2.core.TreeException.TreeException`: If the specified parameter does not exist.
        """
        step = self._entity.GetFlow().LookupSplitStep(param)
        if step is None:
            raise TreeException('Parameter with name "%s" not found' % param)
        
        step.SetDefValue(defaultValue)
        self._entity.SetModified(True)

    def Renumber(self, toSave=False):
        """
        Renumbers nodes of the simulation tree.
        
        :param bool toSave: Save the simulation tree.        
        """
        self._entity.Renumber()
        self._entity.SetModified(True)

        if toSave:
            self.Save()
    
    def SearchNodesByStatus(self, scenario=SWBScenario.ALL, status=STATE_DONE):
        """
        Search the nodes with a specific status.
        The status should be imported from `swbpy2.core.core`
        Status should be one of the following imported values:
        STATE_NULL_NODE, STATE_PRUNED_NODE, STATE_RUNNING, STATE_HIDDEN, STATE_NORMAL, STATE_READY, STATE_FAILED,
        STATE_TERMINATED, STATE_DONE, STATE_ABORTED, STATE_VIRTUAL, STATE_QUEUED, STATE_PENDING, STATE_LOCKED, 
        STATE_UNKNOWN, STATE_NONE
        
        .. Note::
           Please check example 8 in the :ref:`api/swbpy2.gtree:Examples` for use cases.
        
        :param str scenario: Input scenario.
        :param STATE status: Status of the node.
        :raises: TypeError if the state parameter is not one of the above states
        """
        nodes = list()
        for node in self.AllNodes(scenario):
            node_status = self.NodeStatus(node)
            if ConvertEnumToString(status) == node_status:
                nodes.append(node)
        return nodes
        
    @atomic_file_lock
    def BridgeNodeToChildProject(self, node, childProject, opt_tools=None,
                                 files_to_copy=None, folders_to_copy=None):
        """
        Internal use only.  Not supported.        
        """
        
        if isinstance(childProject, str):
            childProjectPath = os.path.abspath(childProject)
            shutil.rmtree(childProjectPath, True)
            isHierarchical = self._entity.ProjectMetadata().IsHierarchical()
            createIfNotExists(childProjectPath, isHierarchical)
            child = Gtree(childProject, True)
        else:
            raise ValueError(f"Child project must be a string with the path")

        # gets a list of tool stages from left to the node's tool stage (inclusive)
        tools = self.AllTools()
        optTool = self.NodeTool(node)

        # Find index of the first tool in the optimisation
        if opt_tools is not None:
            indTools = list()
            for otool in opt_tools:
                indTools.append(tools.index(otool))
            indTool = min(indTools)
        else:
            indTools = [tools.index(optTool) - 1]
        sortedTools = np.sort(indTools)
        indTool = sortedTools[0]

        ptools = tools[0:indTool]
        pvars = self.AllVarNames()
        PStoSync = "all"
        infoLevel = 3

        for tool in sortedTools:
            firstToolNames = self.ToolPnames(tools[tool])
            if firstToolNames:
                break

        # create a child project with Bridge tool (if not the first tool)
        if indTool > 0:
            child.AddTool("bridge", "bridge")
            # get all parameters from the beginning to the first
            # optimisation tool
            lastParam = firstToolNames[0]
            for p in self.AllPnames():
                if p == lastParam:
                    break
                value = self.NodePval(node, p)
                child.AddParam(p, value)

        for itool in indTools:
            otool = tools[itool]
            otool_type = self.DBTool(otool)
            child.AddTool(otool, otool_type)
            child.SetToolCmdline(otool, self.GetToolCmdline(otool))
            child.SetToolComment(otool, self.GetToolComment(otool))
            otool_names = self.ToolPnames(otool)
            for p in otool_names:
                value = self.NodePval(node, p)
                child.AddParam(p, value)

            # create an input command file for point optimization tool
            otool_inputs = glob.glob(os.path.join(self.Project(), f"{otool}_*.*"))
            for otool_input in otool_inputs:
                otool_input = os.path.basename(otool_input)
                shutil.copyfile(os.path.join(self.Project(), otool_input),
                                os.path.join(child.Project(), otool_input))
            # otool_input = otool + "_eng.py"
            # shutil.copyfile(os.path.join(self.Project(), otool_input),
            #                 os.path.join(child.Project(), otool_input))

        # User specified files and folders to copy
        other_files = files_to_copy
        if other_files is None:
            other_files = list()
        if isinstance(other_files, str):
            other_files = [other_files]
        elif not isinstance(other_files, list):
            raise ValueError(f"files_to_copy must be a filename or list of filenames, not {type(other_files)}")

        other_folders = folders_to_copy
        if other_folders is None:
            other_folders = list()
        if isinstance(other_folders, str):
            other_folders = [other_folders]
        elif not isinstance(other_folders, list):
            raise ValueError(f"folders_to_copy must be a folder name or list of folder names, not {type(other_folders)}")

        # Additional enigma specific files:
        other_files += ["base_garand_inputfile.garinp", "gqueues.dat", "gtooldb.tcl"]
        for f in other_files:
            if os.path.exists(os.path.join(self.Project(), f)):
                shutil.copyfile(os.path.join(self.Project(), f),
                                os.path.join(child.Project(), f))
        # Enigma directory
        other_folders += [os.path.join("enigma", "plugins")]
        for f in other_folders:
            if os.path.exists(os.path.join(self.Project(), f)):
                shutil.copytree(os.path.join(self.Project(), f),
                                os.path.join(child.Project(), f))

        # create default experiment
        child.CreateDefaultScenario()

        # save project
        child.Save()
        child.SaveVars()

        # create an input command file for Bridge tool
        if indTool > 0:
            bridgeFile = os.path.join(child.Project(), "bridge_tcl.cmd")
            with open(bridgeFile, 'w') as hf:
                hf.write("#noexec\n")
                hf.write("set Parent \"" + self.Project() + "\"\n")
                hf.write("set ptools \"" + " ".join(ptools) + "\"\n")
                hf.write("set pvars \"" + " ".join(pvars) + "\"\n")
                hf.write("set PStoSync " + PStoSync + "\n")
                hf.write("set infoLevel " + str(infoLevel) + "\n")
        import time

    @atomic_file_lock
    def CollectParamsFromChildProject(self, node, childProject,
                                      opt_params=None, opt_tools=None):
        """
        Internal use only.  Not supported.
        """
        
        if isinstance(childProject, str):
            child = Gtree(childProject)
        else:
            raise ValueError(f"Child project must be a string with the path")
    
        # Read optimal experiment. From any of the experiments we can recover
        # the parameters.
        # Assume no simparams in the target for recovery of variables.
        # Get scenario from the last successful call to optimise()
        child_rscenarios = [s for s in child.AllScenarios() if 'restart' in s]

        # last_restart = sorted(child_rscenarios)[-1]
        if child_rscenarios:
            last_restart = sorted(child_rscenarios, key=lambda x: int(x.split("_")[-1]))[-1]
        else:
            if opt_params or opt_params is None:
                print("WARNING: no optimization scenarios ('restart_*') are present in the child project."
                      "No parameters will be updated.")
            self.LoadTree()
            self.LoadVars()
            self.Save()
            return    
    
        tool_vars = dict()
        for opt_tool in opt_tools:
            for tool_step in child.ToolSteps(opt_tool):
                # TODO: extend to multi-experiment optimisation
                sn = child.AllStepNodes(scenario=last_restart, step=tool_step)[0]
                snvars = child.NodeVariables(sn)
                for i in range(0, len(snvars), 2):
                    tool_vars[snvars[i]] = snvars[i+1]
    
        # Only one node needed to get the parameters
        cnode = child.AllLeafNodes(scenario=last_restart)[0]
        if opt_params is None:
            opt_params_from_file = True
            # If not given, try to read optimal parameters from a file
            with open(os.path.join(child.Project(), 'opt_params.txt')) as f:
                opt_params = dict(x.rstrip().split(maxsplit=1) for x in f)
        else:
            opt_params_from_file = False
            opt_params = {opt_params[i]: child.NodePval(cnode, pname=opt_params[i]) for i in range(len(opt_params))}
    
        # Update gtree to include any changes made by other nodes
        self.LoadTree()
        self.LoadVars()
    
        # Variables from child deck. Only works for single experiment
        # optimisation. TODO: extend to multi-experiment optimisation
        for vname, vvalue in tool_vars.items():
            print(f"DOE: {vname} {vvalue}")
    
        pnodes = list()
        self.LoadVars()
        print("\nChanging parameter values:")
        for pname, pvalue in opt_params.items():
            pv_old, p_type, pnode = self.VarValue(node, pname, loadVars=False)
            print(f"  {pname}: {pv_old} -> {pvalue}")
            if not pnode:
                if not opt_params_from_file:
                    if pname not in self.AllPnames():
                        message = f"SWB parameter '{pname}' specified in the 'opt_params' list of the " \
                                  f"configuration file could not be found. Closest SWB parameters are " \
                                  f"{difflib.get_close_matches(pname, self.AllPnames())}"
                    else:
                        message = f"Value for SWB parameter '{pname}' specified in the 'opt_params' list of the " \
                                  f"configuration file could not be copied from the child optimization " \
                                  f"project in {child.Project()}"
                    raise ValueError(message)
                else:
                    raise ValueError(
                            f"Value for SWB parameter '{pname}' could not be copied from the child optimization"
                            f"project in {child.Project()}")

            pnodes.append(pnode)
            self.ChangeNodeValue(pnode, pvalue)
    
        # Save and release the lock
        self.Save()
    
