# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work
# of Synopsys, Inc., and is fully protected under copyright and
# trade secret laws. You may not view, use, disclose, copy, or
# distribute this file or any information contained herein except
# pursuant to a valid written license from Synopsys.
# ==================================================================

"""
.. currentmodule:: swbpy2.gtree.Deck
"""

import os
import time
import getpass
import socket
import shutil
import weakref

from swbutils.common.Utils import createIfNotExists
from swbutils.common.Utils import remote_cmd
from swbutils.common.Utils import swb_metadata_db
from swbutils.common.Utils import is_traditional
from swbpy2.gtree.gtree import Gtree
from swbpy2.swblmclient.Client import Client
from swbpy2.tool.Standards import Standards
from swbpy2.core.exception.TreeException import TreeException

from swbpy2.core.core import (
    STATE_NONE,
    SWBOrganizationType_TRADITIONAL,
    SWBOrganizationType_UNDEFINED,
    SWBOrganizationType_HIERARCHICAL,
)
from swbpy2.core.core import ConvertEnumToString
from swbpy2.utils import _project_to_csv


class Deck:
    """
    This class allows you to open, modify, execute and export SWB projects. Use this class to create a new project or use an existing one.

    :param str projectpath: SWB project path.
    :param bool isHierarchical: Create a project in hierarchical mode."""

    _isHierarchical = SWBOrganizationType_UNDEFINED

    def __init__(self, projectpath, isHierarchical=True):
        """
        Constructor of Deck object.

        """

        # override project structure if already exists
        # otherwise create as given
        project_path = os.path.abspath(projectpath)
        project_file = project_path + "/.project"

        if os.path.isdir(project_path) and os.path.isfile(project_file):
            self._isHierarchical = not is_traditional(projectpath)
        else:
            self._isHierarchical = isHierarchical
        if swb_metadata_db() and not self._isHierarchical:
             raise Exception("SWB Database Mode does not support projects in Traditional organization.")
        # project path variable
        self._projectpath = project_path

        # check project path
        createIfNotExists(self._projectpath, isHierarchical)

        # SWBLM client connection
        self._client = None

        # Gtree object
        self._gtree = None

        # SWB application objects
        self._apps = None

        # initialize objects
        self._init(self._projectpath)
        weakref.finalize(self, self.finalize)

    def finalize(self):
        """
        Destructor of Deck object.
        """

        # delete SWBLM client object
        if self._client is not None:
            del self._client
            self._client = None

        # delete Gtree object
        if self._gtree is not None:
            del self._gtree
            self._gtree = None

        # delete Standards object
        if self._apps is not None:
            del self._apps
            self._apps = None

    def _init(self, projectpath):
        """
        Internal method to initialise Deck data objects.

        :param str projectpath: SWB project path.
        """

        # update data - SWBLM client connection
        if self._client is not None:
            del self._client
            self._client = None
        self._client = Client(projectpath, "swbpy-client-%s" % str(id(self)))

        # update data - Gtree object
        if self._gtree is not None:
            del self._gtree
            self._gtree = None
        self._gtree = Gtree(projectpath)
        if self._isHierarchical:
            self._gtree._entity.ProjectMetadata().SetOrganizationType(
                SWBOrganizationType_HIERARCHICAL
            )
        else:
            self._gtree._entity.ProjectMetadata().SetOrganizationType(
                SWBOrganizationType_TRADITIONAL
            )

        # update data - SWB application objects
        if self._apps is not None:
            del self._apps
            self._apps = None
        self._apps = Standards()

    def getGtree(self):
        """
        Retrieve project simulation tree as an object.

        :return: Inner instance of the simulation tree object.
        :rtype: :class:`swbpy2.gtree.gtree.Gtree`
        """

        # retrieving internal object
        return self._gtree

    def getPath(self):
        """
        Retrieve SWB project path.
        
        :return: SWB project path.
        :rtype: str
        
        """

        # retrieving internal object
        return self._gtree.Project()    

    def save(self, path=None, clean=False):
        """
        Save current project.

        :param str path: Path where the SWB project should be saved.  If no value is given, then project is saved in the current path.
        :param bool clean: Save instance which is specified in the path param as a clean SWB project.

        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """

        # save current project
        self._gtree.Save()
        self._gtree.SaveVars()

        # check destination path
        if path is not None and os.path.abspath(
            self._gtree.Project()
        ) != os.path.abspath(path):

            # copy entire project in destination path
            shutil.copytree(
                os.path.abspath(self._gtree.Project()), os.path.abspath(path)
            )

            # clean destination path
            if clean:
                self._apps.gcleanup(path, default=True)

            # reset initialisation objects
            self._init(path)

    def cleanup(self, default=True, **kwargs):
        """
        Cleanup project. It wraps ``gcleanup`` binary call.

        :param bool default: If set to True, applies default project cleanup.
        :param ``**kwargs``: Set of cleanup command-line options supported by the `gcleanup` binary. For details, launch the command `gcleanup -h` on your terminal. These options apply if the default parameter is set to False.
        """

        # cleanup current project
        if default:

            # default
            self._apps.gcleanup(path=self._gtree.Project(), default=True)
        else:

            # cleanup current project
            self._apps.gcleanup(path=self._gtree.Project(), default=False, **kwargs)

    def preprocess(self, **kwargs):
        """
        Preprocess project. It wraps 'spp' binary call.

        :param ``**kwargs``: Set of preprocessor command-line options supported by the 'spp' binary. For details, launch the command 'spp -h' on your terminal.

        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """

        # preprocess project
        self._apps.spp(path=self._gtree.Project(), **kwargs)

    def run(self, **kwargs):
        """
        Run project. It wraps 'gsub' binary call.

        :param ``**kwargs``: Set of command-line options supported by the 'gsub' binary. For details, launch the command 'gsub -h' on your terminal. If no arguments are provided, it launches the whole project.

        .. Note::

           Please check with :ref:`api/swbpy2.gtree:Examples` for use cases.
        """

        # run project
        if len(kwargs) <= 0:

            # use arguments
            self._apps.gsub(self._gtree.Project(), expr="all")
        else:

            # default, run all nodes
            self._apps.gsub(self._gtree.Project(), **kwargs)

    def abort(self, nodes=[]):
        """
        Abort given running nodes or the whole project.

        :param list nodes: List of running nodes to abort. If the list is empty, all running nodes of the projects will be aborted.
        """

        # check abort project or nodes
        if len(nodes) > 0:

            # abort single nodes
            self._client.AbortNodes(nodes=nodes)

            return

        # abort genopt (if any)
        pidFile = os.path.join(self._gtree.Project(), ".genoptpid")
        if os.path.exists(pidFile):
            with open(pidFile, "r") as f:
                host = f.readline()
                ppid = f.readline()
                if host == os.uname().nodename or host == socket.getfqdn():
                    os.kill(int(ppid), signal.SIGTERM)
                else:
                    remote_cmd(host, "kill -TERM %s" % ppid)

        # abort all nodes
        self._client.AbortNodes()

    def reload(self, saveBeforeReload=False):
        """
        Reload project in the context of Deck object. In addition, if the same project is opened in SWB GUI, this command communicates reload command to SWB.

        :param bool saveBeforeReload: saves the project before initiating a reload.  Default is False.
        """

        # save current project
        if saveBeforeReload:
            self.save()

        # reinitialize data structures
        self._init(self._projectpath)

        # reload project in SWB graphical interface
        self._client.ReloadInSWB()

    def rename(self, newName):
        """
        Placeholder for future implementation.  Do not use.
        """

        # status
        deckStatus = self.status()

        # check running project
        if deckStatus in ("running", "ready", "queued", "pending"):
            raise TreeException(
                'Rename operation failed, project is still in "%s" status' % deckStatus
            )

        # check if not yet saved
        if self._gtree.GetEntity().IsModified():
            raise TreeException(
                "Rename operation failed, project is modified and not yet saved"
            )

        # current path
        src = self._gtree.Project()

        # check new path
        dst = os.path.abspath(os.path.join(os.path.dirname(src), newName))

        # rename project
        os.rename(src, dst)

        # reset initialisation objects
        self._init(dst)

    def status(self):
        """
        Retrieve the project status from file system.

        :return: Returns the current status which will be one of the following values: none, ready, done, failed, aborted.
        :rtype: str
        """

        # get project status
        status = os.path.join(self._gtree.Project(), ".status")
        parts = []
        with open(status, "r") as hf:
            line = hf.readline()
            parts = line.split("|")

        if len(parts) >= 4:
            state = parts[3]
        else:
            state = ConvertEnumToString(STATE_NONE)
        return state

    def resetStatus(self, newstatus = "none"):
        """
        Reset project status.  This sets the project status:
         | Change timestamp: Current time.
         | Host: Current host FQDN.
         | User: Current user.
         | State: NONE.
         | PID: Current running pid value.
        """

        # reset status
        status = os.path.join(self._gtree.Project(), ".status")
        with open(status, "w") as hf:
            ts = int(time.time())
            host = socket.getfqdn()
            user = getpass.getuser()            
            pid = os.getpid()
            line = "{}|{}|{}|{}|{}".format(ts, host, user, newstatus, pid)
            hf.write(line)

    def export(self, csvfile=None):
        """
        Exports data of current project to CSV format.
  
        Header composition:
         | 1st line: tool names
         | 2nd line: tool labels
         | 3rd line: parameter names and variable names

        :param str csvfile: File where the CSV data should be saved. If no value is given, returns CSV data without saving.
        :return: Returns project data as CSV.
        :rtype: str
        """
        csvdata = _project_to_csv(self._gtree)
        if csvfile:
            with open(csvfile, "w") as hf:
                hf.write(csvdata)
        
        return csvdata
        
