"""Utility functions for Rayuela."""


from collections.abc import (
    Hashable as _Hashable,
    Iterable as _Iterable,
)

from functools import wraps as _wraps
from secrets import token_hex as _random_hex_string
from threading import get_ident as _get_thread_id


no_default = _random_hex_string(16)


def generate_infinite(function, *args, **kwargs):
    """Generate infinite values from calling ``function``.

    Example::

        >>> from itertools import islice
        >>> say_yes_to_everything = generate_infinite(lambda: "yes")
        >>> [*islice(say_yes_to_everything, 5)]
        ['yes', 'yes', 'yes', 'yes', 'yes']
    """
    while True:
        yield function(*args, **kwargs)


def set_value_on_dynamic_dict(dictionary, keys, value):
    """Set a value at arbitrary depth in a dictionary."""
    if isinstance(keys, (str, bytes)):
        keys = [keys]

    try:
        current_key, *other_keys = keys

        if other_keys:
            inner_dict = dictionary.setdefault(current_key, {})
            set_value_on_dynamic_dict(inner_dict, other_keys, value)

        else:
            dictionary[current_key] = value

    except TypeError:
        try:
            iter(keys)

        except TypeError:
            set_value_on_dynamic_dict(dictionary, [keys], value)

        else:
            raise


def deep_dict_get(dictionary, keys, default=no_default):
    """Get a value at arbitrary depth from a dictionary."""
    try:
        current_key, *other_keys = keys

        if other_keys:
            inner_dict = dictionary[current_key]
            return deep_dict_get(inner_dict, other_keys, default)

        else:
            return dictionary[current_key]

    except TypeError:
        try:
            iter(keys)

        except TypeError:
            return deep_dict_get(dictionary, [keys], default)

        else:
            raise

    except KeyError:
        if isinstance(keys, _Hashable) and isinstance(keys, _Iterable):
            return deep_dict_get(dictionary, [keys], default)

        elif current_key not in dictionary and default != no_default:
            return default

        else:
            raise


def stack_overflow_guard(function):
    """Decorate ``function`` to assert you haven't entered before.

    Yes, I needed this :(.

    This is meant to debug stack overflows. If you enter the decorated
    function twice, an AssertionError is raised showing the stack trace
    that got you into this state. Of course this only works for
    non-recursive functions.
    """
    _loop_guard = set()

    @_wraps(function)
    def wrapper(*args, **kwargs):
        nonlocal _loop_guard
        thread_id = _get_thread_id()

        assert thread_id not in _loop_guard

        _loop_guard.add(thread_id)

        try:
            return function(*args, **kwargs)

        finally:
            _loop_guard.remove(thread_id)

    return wrapper


# ****************************************
# AppDigest signature for component RAYUELA. Do not delete!
# ****************************************
# @(&)Synopsys_Unique_Signature Libname="utils.py" Name="RAYUELA" Version="4.0.0" Type="REUSE" Injector="V-2023.09-DEV (8729328)"(&)@
