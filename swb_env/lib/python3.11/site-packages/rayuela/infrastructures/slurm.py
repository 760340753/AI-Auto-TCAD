"""Provide an :class:`Infrastructure` to run tasks on slurm host."""


from inspect import (
    Parameter as _Parameter,
    signature as _signature,
)

from typing import (
    Mapping as _Mapping,
    Optional as _Optional,
    Sequence as _Sequence,
)

from warnings import (
    catch_warnings as _catch_warnings,
    simplefilter as _simplefilter,
)


from dask_jobqueue import (  # type: ignore
    JobQueueCluster as _JobQueueCluster,
    SLURMCluster as _SLURMCluster,
)

from dask_jobqueue.core import Job as _Job  # type: ignore
from dask_jobqueue.slurm import SLURMJob as _SLURMJob  # type: ignore
from distributed.security import Security as _Security  # type: ignore


from .infrastructure import (
    Fingerprint as _Fingerprint,
    Infrastructure as _Infrastructure,
)

from .mixins import AdaptOnFirstSubmit as _AdaptOnFirstSubmit

from .utils import (
    parameter as _parameter,
    process_start_dashboard as _process_start_dashboard,
    set_directory as _set_directory,
    start_dashboard_param as _start_dashboard_param,
    to_hashable as _to_hashable,
    with_parameters as _with_parameters,
)


# fmt: off

_identity_parameters = [
    _parameter(_Job, "cores", _Optional[int], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "env_extra", _Optional[_Sequence], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "extra", _Optional[_Sequence], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "header_skip", _Optional[_Sequence], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "job_extra_directives", _Optional[_Sequence], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_Job, "memory", _Optional[str], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_Job, "processes", _Optional[int], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "python", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "shebang", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_JobQueueCluster, "asynchronous", _Optional[bool], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_SLURMJob, "job_cpu", _Optional[int], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_SLURMJob, "job_mem", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_SLURMJob, "project", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_SLURMJob, "queue", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_SLURMJob, "walltime", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
]

_incidental_parameters = [
    _parameter(_Job, "death_timeout", _Optional[float], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "job_name", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "local_directory", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "log_directory", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_Job, "nanny", _Optional[bool], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_JobQueueCluster, "config_name", _Optional[str], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_JobQueueCluster, "interface", _Optional[str], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_JobQueueCluster, "n_workers", _Optional[int], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_JobQueueCluster, "name", _Optional[str], kind=_Parameter.KEYWORD_ONLY),
    _parameter(_JobQueueCluster, "scheduler_options", _Optional[_Mapping], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_JobQueueCluster, "security", _Optional[_Security], kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _parameter(_JobQueueCluster, "silence_logs", _Optional[str], default="critical", kind=_Parameter.KEYWORD_ONLY),  # noqa: E501
    _start_dashboard_param,
]

# fmt: on


class _PatchedSLURMJob(_SLURMJob):
    cancel_command = "scancel --signal=INT"
    """This patch fixes an issue where terminating a worker causes a
    deadlock in Rayuela when the :class:`Infrastructure`'s finalizers
    are run. I don't know why the deadlock happens, but it seems to be
    related to the worker being finalized forcefully with a termination
    signal. Sending INT (equivalent to control+c) instead of TERM fixes
    the issue by allowing the worker to exit gracefully."""


class _TCADSLURMCluster(_SLURMCluster):
    job_cls = _PatchedSLURMJob


class SLURMInfrastructure(_AdaptOnFirstSubmit, _Infrastructure):
    """:class:`Infrastructure` that can run tasks on the slurm host."""

    @_with_parameters(
        _Parameter("self", _Parameter.POSITIONAL_ONLY),
        *_identity_parameters,
        *_incidental_parameters,
    )
    def __init__(self, **kwargs):
        """Configure a :class:`distributed.SLURMCluster`."""
        self._bound_args = _signature(self.__init__).bind(**kwargs)
        bound_args = _signature(self.__init__).bind(**kwargs)
        bound_args.apply_defaults()

        _process_start_dashboard(bound_args.arguments)
        _set_directory("local_directory", self, bound_args.arguments)
        _set_directory("log_directory", self, bound_args.arguments)

        with _catch_warnings():
            _simplefilter("ignore")

            self._cluster = _TCADSLURMCluster(*bound_args.args, **bound_args.kwargs)

        super().__init__()

    @classmethod
    @_with_parameters(
        _Parameter("cls", _Parameter.POSITIONAL_ONLY),
        *_identity_parameters,
        _Parameter("kwargs", _Parameter.VAR_KEYWORD),
    )
    def compute_fingerprint(cls, **kwargs) -> _Fingerprint:
        """Return the hash of this class and the processes parameter."""
        signature = _signature(cls.compute_fingerprint)

        bound_args = signature.bind(**kwargs)
        bound_args.apply_defaults()
        del bound_args.arguments["kwargs"]

        def hashable(name):
            return _to_hashable(
                signature.parameters[name].annotation, bound_args.arguments[name]
            )

        arg_tuple = (cls, *map(hashable, bound_args.arguments))
        return hash(arg_tuple)

    def __hash__(self):
        """Return the fingerprint of this instance."""
        return self.compute_fingerprint(
            *self._bound_args.args, **self._bound_args.kwargs
        )

    def get_cluster(self):
        """Return an instance of :class:`dask_jobqueue.SLURMCluster`."""
        return self._cluster

    def get_job_ids(self, future):
        """Return iterable of job ids involved in processing ``future``."""

        def get_job_id():
            from os import environ

            return environ["JOB_ID"]

        workers = self.who_has_future(future)
        return tuple(self.run_on_workers(workers, get_job_id).values())


# ****************************************
# AppDigest signature for component RAYUELA. Do not delete!
# ****************************************
# @(&)Synopsys_Unique_Signature Libname="slurm.py" Name="RAYUELA" Version="4.0.0" Type="REUSE" Injector="V-2023.09-DEV (8729328)"(&)@
