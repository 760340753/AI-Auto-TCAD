"""Infrastructure mixin library.

This module provides a library of
:class:`~rayuela.infrastructures.infrastructure.Infrastructure` mixins.
Each mixin should provide additional
:class:`~rayuela.infrastructures.infrastructure.Infrastructure`
functionality to be used in the final infrastructure classes using
multiple inheritance.

For example, let's say we need to provide a greeting functionality for
infrastructure classes. A mixin providing such functionality may look
like this:

>>> from rayuela.infrastructures.infrastructure import Infrastructure
>>>
>>> class Greeter():
...     def __init__(self, *args, **kwargs):
...         print("Hi there!")
...         super().__init__(*args, **kwargs)

Then we would mix in this class with a final infrastructure
implementation:

>>> from unittest.mock import MagicMock
>>>
>>> class GreeterInfrastructure(Greeter, Infrastructure):
...     def __init__(self):
...         self._cluster = MagicMock(name="cluster")
...         super().__init__(_ClientClass=MagicMock())
...
...     @classmethod
...     def compute_fingerprint(cls):
...         return hash(cls)
...
...     def __hash__(self):
...         return self.compute_fingerprint()
...
...     def get_cluster(self):
...         return self._cluster
...
>>> infra = GreeterInfrastructure()
Hi there!

This is a trivial case, but you can actually add as many mixins as you
want. If you happen to add multiple mixins (maybe conflicting with each
other), then the methods of the mixins specified at the beginning will
have preference over the others.
"""


from ..deploy.adaptive import TCADAdaptive as _TCADAdaptive
from .infrastructure import Infrastructure as _Infrastructure


class Adaptable(_Infrastructure):
    """Make an infrastructure adaptable.

    Adaptable infrastructures can scale their workers up or down
    depending on the load of tasks.
    """

    def adapt(self, *args, Adaptive=_TCADAdaptive, **kwargs):
        """Start the adaptive mechanism on this infrastructure."""
        with self._cluster_lock:
            adaptive = self.get_cluster().adapt(*args, Adaptive=Adaptive, **kwargs)
            self.sync(adaptive.adapt)
            return adaptive


class AdaptOnFirstSubmit(Adaptable, _Infrastructure):
    """Calls ``self.adapt()`` on the first submit.

    This mixin class adds the functionality of adapting the cluster
    after the first submit.

    This is useful for checking if the cluster can launch workers. If
    workers cannot be launched, an exception should be raised, making
    the submit call report the error appropriately.

    By calling ``self.adapt()`` this mixin will also start a periodic
    callback process that will continuously check the load of the
    cluster, scaling it up or down if necessary.

    This is pretty convenient, because it enables the instantiation of
    an :class:`~rayuela.infrastructures.infrastructure.Infrastructure`
    without starting any workers until it's necessary to do so.

    Some infrastructures should not adapt after being created. This is
    the case of the
    :class:`~rayuela.infrastructures.local.LocalInfrastructure` and
    :class:`~rayuela.infrastructures.dummy.DummyInfrastructure`.
    """

    def __init__(self, *args, **kwargs):
        """Initialize a variable to record if adapt was called or not."""
        self._adapting = False
        super().__init__(*args, **kwargs)

    def submit(self, *args, **kwargs):
        """Submit function to SGE and adapt the cluster to handle it."""
        task = super().submit(*args, **kwargs)

        if not self._adapting:
            self.adapt()
            self._adapting = True

        else:
            pass

        return task


# ****************************************
# AppDigest signature for component RAYUELA. Do not delete!
# ****************************************
# @(&)Synopsys_Unique_Signature Libname="mixins.py" Name="RAYUELA" Version="4.0.0" Type="REUSE" Injector="V-2023.09-DEV (8729328)"(&)@
