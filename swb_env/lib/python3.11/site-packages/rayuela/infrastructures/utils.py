"""Provide utilities to work with infrastructures."""


from inspect import (
    Parameter as _Parameter,
    signature as _signature,
)

from pathlib import Path as _Path

from tempfile import TemporaryDirectory as _TemporaryDirectory

from typing import (
    Iterable as _Iterable,
    Mapping as _Mapping,
    MutableMapping as _MutableMapping,
    Optional as _Optional,
    Sequence as _Sequence,
    Set as _Set,
)

from weakref import finalize as _finalize


from .infrastructure import Infrastructure as _Infrastructure


def parameter(
    callable,
    name,
    type_=_Parameter.empty,
    default=_Parameter.empty,
    kind=_Parameter.empty,
):
    """Return the specified parameter from callable.

    If supplied, ``kind`` and ``default`` are overwritten.

    If ``type_`` is supplied, it will be checked against the original
    parameter annotation:

    *   If both are the same, passing type will have no effect.
    *   If both are different, ``ValueError`` will be raised.
    *   If the original parameter does not specify an annotation, the
        returned annotation will be ``type_``.
    """
    param = _signature(callable).parameters[name]

    replacements = {}

    if kind != _Parameter.empty:
        replacements.update(kind=kind)

    if default != _Parameter.empty:
        replacements.update(default=default)

    if (
        type_ != _Parameter.empty
        and param.annotation != _Parameter.empty
        and type_ != param.annotation
    ):
        raise ValueError(
            f"Original type is {param.annotation}, does not match {type_}."
        )

    elif type_ != _Parameter.empty and param.annotation == _Parameter.empty:
        replacements.update(annotation=type_)

    else:
        pass

    return param.replace(**replacements)


def with_parameters(*parameters):
    """Apply signature to the decorated function."""

    def decorator(function):
        function.__signature__ = _signature(function).replace(parameters=parameters)
        return function

    return decorator


def to_hashable(type_, value):
    """Transform value to a hashable form."""
    if type_ == _Optional[_Sequence]:
        return value if value is None else to_hashable(_Sequence, value)

    elif type_ == _Optional[_Mapping]:
        return value if value is None else to_hashable(_Mapping, value)

    elif type_ == _Sequence:
        return tuple(value)

    elif type_ == _Mapping:
        return to_hashable(_Sequence, sorted(value.items()))

    else:
        return value


def recursive_to_hashable(value):
    """Transform value to a hashable form.

    This function is recursive, and will transform all nested
    mappings and sequences to hashable forms.

    This function is similar to :func:`to_hashable`, but it will
    transform all nested mappings and sequences to hashable forms. Both
    were developed at separate times, and are not necessarily
    equivalent. I have not yet determined whether we can replace
    :func:`to_hashable` with this function.

    :param value: The value to transform.
    :return: A hashable form of the value.
    """
    if isinstance(value, str):  # noqa: R505
        return value

    elif isinstance(value, _Set):
        return frozenset(recursive_to_hashable(item) for item in value)

    elif isinstance(value, _Mapping):
        return recursive_to_hashable(sorted(value.items()))

    elif isinstance(value, _Iterable):
        return tuple(recursive_to_hashable(item) for item in value)

    else:
        return value


start_dashboard_param = _Parameter(
    "start_dashboard", _Parameter.KEYWORD_ONLY, default=False, annotation=bool
)


def process_start_dashboard(args):
    """Initialize the scheduler_options.dashboard_address parameter."""
    args["scheduler_options"] = (
        {} if args["scheduler_options"] is None else args["scheduler_options"]
    )

    if args["start_dashboard"]:
        args["scheduler_options"].setdefault("dashboard_address", ":0")

    else:
        args["scheduler_options"]["dashboard_address"] = None

    del args["start_dashboard"]


def set_directory(option_name: str, self: _Infrastructure, args: _MutableMapping):
    """Initialize a directory argument properly.

    :param option_name: The name of the option to initialize.
    :param self: The infrastructure instance.
    :param args: The arguments to initialize.
    """
    if args[option_name] is None:
        directory = _TemporaryDirectory(prefix=".tmp", dir=_Path.cwd())
        _finalize(self, directory.cleanup)
        args[option_name] = directory.name

    else:
        pass


# ****************************************
# AppDigest signature for component RAYUELA. Do not delete!
# ****************************************
# @(&)Synopsys_Unique_Signature Libname="utils.py" Name="RAYUELA" Version="4.0.0" Type="REUSE" Injector="V-2023.09-DEV (8729328)"(&)@
