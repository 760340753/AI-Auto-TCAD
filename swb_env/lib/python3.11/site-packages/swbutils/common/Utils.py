# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work  
# of Synopsys, Inc., and is fully protected under copyright and     
# trade secret laws. You may not view, use, disclose, copy, or      
# distribute this file or any information contained herein except   
# pursuant to a valid written license from Synopsys.                
# ==================================================================

"""
.. currentmodule:: swbutils.common.Utils

Collection of utility methods.
"""

import getpass
import math
import os
import pathlib
import re
import shlex
import socket
import subprocess
import sys

from logging import (
    basicConfig as _configure_root_logger,
    StreamHandler as _StreamHandler,
)


import psutil
import numpy as np


def _get_fullpath(foldername, filename):
    pathname = os.path.dirname(sys.argv[0]) if foldername is None else os.path.dirname(os.path.realpath(foldername)) 
    absFileName = os.path.join(os.path.abspath(pathname) , filename)
    return absFileName

# parse XML preference file
def parse_pref( xmlfile ):
    if not os.path.isfile(xmlfile):
        return [None, None]
    contents = pathlib.Path(xmlfile).read_text()
    matchObj = re.findall(r'<Key="organization,hierarchical,project_output_location"[\s]+Value="([^"]+)"[\s]+Editable="([^"]+)"', contents, re.M|re.I)
    if matchObj:
        return matchObj[0]
    else:
        return [None, None]
    
def parse_pref_key( xmlfile, key):
    if os.path.isfile(xmlfile):
        contents = pathlib.Path(xmlfile).read_text()

        matchObj = re.findall(
            r'<Key="' + key + r'"[\s]+Value="([^"]+)"[\s]+Editable="([^"]+)"',
            contents,
            re.M|re.I,
        )

        if matchObj:
            if matchObj[0][1] == 'true':
                return matchObj[0][0]
    
    return None

    
def is_traditional(projectpath):

    orgfile = os.path.join(projectpath, ".organization")
    traditional = True
    if os.path.isfile(orgfile):
        hf = open(orgfile,"r")
        str = hf.readline()
        hf.close()
        ind = str.find("hierarchical")
        if ind >= 0:
            traditional = False
    return traditional

# raises exception if the name contains a prohibited character   
def check_project_name(name):
    invalid = re.compile("[" + re.escape(r'/\~*?$!"<>:[]{}=|;') + r"\t\s]")
    match = invalid.search(name)
    if match is not None:
        raise ValueError(f"Character '{match.group()}' cannot be used in SWB project names. Invalid characters are "
                         r'[]/\~*?$!<>:{}=|;<tab><space>')

def cast2str( value ):
    return value if isinstance(value, str) else repr(value)

def cast2number(value):
    try:
        value = int(value)
    except ValueError:
        try:
            value = float(value)
        except ValueError:
            pass
    
    return value


def isclose(a, b, **kwargs):
    """
    Check if two variables are close allowing for floating point
    accuracy and string representation.
    """
    if isinstance(b, type(a)):
        if isinstance(b, float):
            return math.isclose(a, b, **kwargs)
        else:  # isinstance(b, (str, int):
            return a == b
    else:
        if isinstance(a, float) or isinstance(b, float):
            return math.isclose(float(a), float(b), **kwargs)
        else:
            return int(a) == int(b)

def allclose(a, b, **kwargs):
    """
    Compare the contents of two iterables accounting for floating point
    accuracy and string conversions.
    """
    if np.isscalar(a):
        a = [a]
    if np.isscalar(b):
        b = [b]
    lena = sum(1 for ai in a)
    lenb = sum(1 for bi in b)
    if lena != lenb:
        raise ValueError(f"Iterables a and b have different lengths,"
                         f"{lena} != {lenb}.")
    close = True
    for ai, bi in zip(a, b):
        close *= isclose(ai, bi, **kwargs)
    return close

def createIfNotExists(path_to_project, hierarchical=False):
    if not os.path.exists(path_to_project):
        os.makedirs(path_to_project)
        if hierarchical:
            with open(os.path.join(path_to_project, ".organization"), "w") as f:
                f.write("hierarchical 0")
        projectFile=os.path.join(path_to_project,".project")
        p = pathlib.Path(projectFile)
        p.touch()

def remote_cmd(host, cmd, standardout=subprocess.DEVNULL, standarderr=subprocess.DEVNULL):
    
    # build command
    cmd = shlex.quote('ssh -o ConnectTimeout=3 -o BatchMode=yes {} {}'.format(host, cmd))
    
    # subprocess invocation
    p = subprocess.Popen(cmd, shell=True, stdout=standardout, stderr=standarderr, preexec_fn=os.setsid)

    # wait for termination
    code = p.wait(5)
    
    # return code
    return code

def get_process_info():
    pinfo = dict()
    pinfo["pname"] = psutil.Process().name()
    pinfo["pid"] = os.getpid()
    pinfo["host"] = socket.gethostname()
    pinfo["username"] = getpass.getuser()
    return pinfo

def swb_metadata_db():
    bDBMode = False
    if "SWB_METADATA_DB" in os.environ:
        bDBMode = os.environ["SWB_METADATA_DB"] == '1'
    return bDBMode


def configure_logging():
    """Set a basic logging configuration for the root logger.

    This function configures the root logger with a handler that prints
    only error messages to the standard error stream. Calling this will
    ensure that gsub output is not polluted with unwanted logging
    messages.
    """
    _log_handler = _StreamHandler()
    _log_handler.setLevel("ERROR")

    _configure_root_logger(
        level="DEBUG",
        style="{",
        format="{levelname} - {name}: {message}",
        force=True,
        handlers=[_log_handler],
    )
