from datetime import datetime
import os
import shutil
import glob

from swbutils.model.Singleton import singleton
from swbutils.mongo.mongomon import MongoMon
from swbutils.mongo.mongologger import MongoLogger
from swbutils.mongo.mongopersist import MongoPersist

@singleton
class MongoMig():
    migfolder = "/_migration"
    lg = None
    opath = None
    mpath = None
    
    def __init__(self):
        self.lg = MongoLogger()
        self.lg.Print("Initiating singleton MongoMig")
        
    

    def _MoveResultsFiles(self, frompath, topath):
          # if hierarchical, do results folders for .sta files
        rpath = frompath + '/results'
        if os.path.exists(rpath):
            files = glob.glob(rpath + '/**/n*_*.sta', recursive = True) 
            for file in files: 
                #self.lg.Print(file)
                relpart = file.find('/results')
                relpart = file[relpart:]
                relpath= topath + os.path.split(relpart)[0] + '/'
                if not os.path.exists(relpath):
                    os.makedirs(relpath, 0o777, True)
                shutil.move(file, relpath)

    def _BackUpFiles(self):
        # Without a gtree.dat file, a backup set of files has no value.  
        gt = orgf = self.opath + '/' + 'gtree.dat'
        if (not os.path.exists(gt)):
            self.lg.Print (f'_BackUpfiles not required as no gtree.dat file')
            return
        files = { 
                'gtree.dat',
                'gtree.dat.backup',
                'gvars.dat',
                'gcomments.dat',
                'gscens.dat',
                'gexec.cmd',
                '.database',
                #'.project',
                #'.organization',
                '.status',
                'n*_*.sta'
            }  

        try:
            if os.path.exists(self.mpath):
                self.lg.Print (f'_BackUpfiles migration path already exist, trying to remove it : {self.mpath}')
                shutil.rmtree(self.mpath) 
            os.mkdir(self.mpath)
            self.lg.Print (f'_BackUpfiles created migration path: {self.mpath}')
        except Exception as e:
            if os.path.exists(self.mpath):
                self.lg.Print (f'_BackUpfiles dir creation exception ignored : {e}')
            else:
                self.lg.Print (f'_BackUpfiles dir creation failed: {e}')
                return

        validBackup = False
        for fdesc in files:
            orgf = self.opath + '/' + fdesc
            for file in glob.glob(orgf):
                self.lg.Print(f"Backing up file {file}")
                if file.endswith('.status'):
                    shutil.copy(file, self.mpath)
                else:
                    shutil.move(file, self.mpath)

        
        # if hierarchical, do results folders for .sta 
        try:
            self._MoveResultsFiles(self.opath, self.mpath)
            if not validBackup:
                shutil.rmtree(self.mpath) 
        except Exception as e:
            if os.path.exists(self.mpath):
                self.lg.Print (f'_BackUpfiles could not be removed: {e}')
    
    def _RestoreFromBackup(self):
        
        self.lg.Print(f"Restoring from backup:")
        self.lg.Print(f"To   {self.opath}")
        self.lg.Print(f"From {self.mpath}")
        try:
            for file in glob.glob(self.mpath + '/*.*'):
                if not os.path.isdir(file):
                    self.lg.Print(f"Restoring file {file}")
                    shutil.move(file, self.opath)

            self._MoveResultsFiles(self.mpath, self.opath)
            return
        except Exception as e:
                self.lg.Print (f'_RestoreFromBackup failed {e}')
        return 


    def _ImportMetaData(self, parent, prj, db, marker):
        self.lg.Print("_Import Metadata called")
        validated = False
        self.opath = parent
        self.mpath = prj + self.migfolder
        
        # call the migration script
        if MongoPersist().Import(parent, db):
            validated = True
            self._BackUpFiles()
        else:
            self.lg.Print("_ImportMetaData Failed")
            # don't need to restore as Backup only made on success
            MongoMon().DisOwn(parent, marker)
            
        return validated
        
    def _MarkMigration(self, db):
        current_date_time = datetime.today()
        dt = current_date_time.strftime('%d/%m/%y %I:%M %S %p')
        datedoc = {"Date" : dt}
        db.Create(MongoMon().dbname, "migration", datedoc)

    def ImportRequired(self, project, marker):
        self.lg.Print(f'ImportRequired called for {project}')
        mfile = f"{project}/.is{marker}db"
        if os.path.exists(mfile):
            # double check that db folder does indeed exist
            if not os.path.exists(f"{project}/.projectdata"):
                # no then is there a migration folder to restore
                #  in case of prior error
                self.mpath = project + self.migfolder
                if os.path.exists(self.mpath):
                    self.opath = project
                    self._RestoreFromBackup()
                    MongoMon().DisOwn(project, marker)
                self.lg.Print('ImportRequired returning True as restore occured')
                return True
                
            self.lg.Print( f'ImportRequired, marker and db exists already in {project}/.projectdata')

        gtree = f"{project}/gtree.dat"
        ret = os.path.exists(gtree)
        self.lg.Print(f'ImportRequired checked gtree.dat existed and returned {ret}')
        return ret
            
    def ImportMetaData(self, project, marker):
        try:
            self.lg.Print(f'ImportMetaData called for {project}')
            db = MongoMon().Connection(project)
            dd = MongoMon().ProjectDD(project)
            pprj = dd['parentproject']
            self.lg.Print(f'Parent {pprj}')
            
            if 'IsUsingTemp' in dd:
                prj = dd['-tmpdir']
            else:
                prj = dd['-project']
            self.lg.Print(f'Project {prj}')
            if self._ImportMetaData(pprj, prj, db, marker):
                self._MarkMigration(db)
                return True
            return False
        except Exception as e:
                self.lg.Print (f'ImportMetaData failed {e}')
                pass  
        
        return False

    def InitDB(self, project, marker):
        try:
            self.lg.Print(f'InitDB called for {project}')
            db = MongoMon().Connection(project)
            MongoPersist().CreateCollections(db)
            self._MarkMigration(db)
            return True
        except Exception as e:
            dd = MongoMon().ProjectDD(project)
            pprj = dd['parentproject']
            self.lg.Print(f'Parent {pprj}')
            self.lg.Print(f"InitDB Failed {e}")
            MongoMon().DisOwn(pprj, marker)
            return False
            
