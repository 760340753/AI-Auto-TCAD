# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work  
# of Synopsys, Inc., and is fully protected under copyright and     
# trade secret laws. You may not view, use, disclose, copy, or      
# distribute this file or any information contained herein except   
# pursuant to a valid written license from Synopsys.                
# ==================================================================
from pathlib import Path
from subprocess import Popen
import shutil
import os
import socket
import datetime
import time
from swbutils.model.Singleton import singleton
from swbutils.mongo.mongologger import MongoLogger
from swbutils.mongo.mongodb import MongoDB
from swbutils.mongo.mongoswboperations import MongoSwbOperations
from swbutils.mongo.mongoutil import MongoUtil
from swbutils.common.Utils import get_process_info

@singleton
class MongoMon():
    pass
    
    dbname = "SynopsysMongoMon"
    lg = None
    cacheName = None
    mydict = {}
    projects = {}

    def __init__(self):
        self.lg = MongoLogger()
        self.lg.Print("Initiating singleton MongoMon")

    def __dictVal(self, k):
        if k not in self.mydict:
            return ""
        else:
            return self.mydict[k]
        
    def __setProps(self):
        self.root = "/.projectdata"
        self.conf = "/mongomon.conf" 
        self.project = self.__dictVal('-project')
        self.activeconf = self.__dictVal('-tmpdir') + self.root + self.conf
        self.port =  self.__dictVal('-commsport')
        self.host =  self.__dictVal('-parenthost')
            
    def __setUp(self, ddict):
        self.mydict = {}
        for k in ddict.keys():
            self.mydict[k] = ddict[k] 
      
        self.__setProps()                          
    
    def __reloadFromActiveConf(self):

        self.lg.Print("Loading conf from " + self.activeconf )
        file1 = open(self.activeconf , "r")
        
        #build arg dictionary
        for line in file1:
            line = line.strip()
            arg = line.split(" ")
            if len(arg) > 1:
                self.mydict[arg[0]] = arg[1]
            else:
                self.mydict[arg[0]] = 'True'
    
        file1.close
        self.__setProps()
    
    def __launchBinary(self, fname, cmdline, block = True):
        try:  
            retcode = 0 
            cmdline = fname + " " + cmdline
            self.lg.Print("Launching binary:")
            self.lg.Print(cmdline)

            p = Popen(cmdline, shell = True) 
            if block:
                retcode = p.wait()
            #self.lg.Print("Launch returned " + str(retcode))
            return (retcode == 0)
        except Exception as ex:
            self.lg.Print("failed to launch file: " + fname, ex)         
        return False
    
    def __launch(self, data):
        
        try: 
            self.__setUp(data)            
                
            cmdline = ""
            for k in self.mydict.keys():
                if k != "-mongomonbin":
                    cmdline = cmdline + " " + k + " " + self.mydict[k]
            
            if self.__launchBinary(self.mydict["-mongomonbin"], cmdline):
                self.__reloadFromActiveConf()
                return True
            else:    
                return False
        except Exception as e:
            self.lg.Print(f"Exception: {e}")
        return False
            
    
    #Helper methods to encapsulate mongmon and db   
    def __adjustedPrjPath(self, prj):
        normalized_project_path = os.path.realpath(prj)
        adjustedPath  = normalized_project_path.replace("/", "_")
        adjustedPath = "mdb" + adjustedPath + f'_{MongoUtil.GetDecoratedPath()}'
        return adjustedPath
        
    def __add(self, cachename):   
        #add project, overwrite prevoius as we may have reopened in same session 
        #if not cachename in self.projects:
        myprj = {}
        for key in self.mydict:
            myprj[key] = self.mydict[key]                
        self.projects[cachename] = myprj
        
    def __del(self, cachename):
        if cachename in self.projects:
            del self.projects[cachename]
    
        
    def Exists(self, project):
        cachename = self.__adjustedPrjPath(project)
        if cachename in self.projects:        
            #self.lg.Print(f'Project already exists: {cachename}')
            return True
        return False
            

    def GetSwbOperations(self, project):
        if self.Connection(project) is None:
            self.Connect(project)
        return MongoSwbOperations(self.Connection(project))
    
    def CopyNodesToProject(self, source_project, destination_project, nodes, clean):
        try:
            source_operations = MongoSwbOperations(self.Connection(source_project))
            node_data_dict = source_operations.CollectAllMetaDataForGivenNodesAndProject(nodes, eval(clean))        
            self.Connect(destination_project)
            destination_operations = MongoSwbOperations(self.Connection(destination_project))
            destination_operations.PersistAllMetaDataForNodes(node_data_dict,  eval(clean))
        except Exception as e:
            self.lg.Print(f"CopyNodesToProject exception: {e}")
        finally:            
            self.ShutDownMongoMon()


    def SetTree(self, tree, project):
        cacheName = self.__adjustedPrjPath(project)
        self.lg.Print(f'Setting tree for {cacheName}')
        self.projects[cacheName]['tree'] = tree

    def _SetOwner(self, path, owner):
        try:
            if not owner is None and owner != "":
                if "IsProjectOwner" in self.mydict.keys():
                    Path(path).joinpath(f'.is{owner}db').touch()
                    return True
        except Exception as e:
            pass
        return False

    def DisOwn(self, project, owner):
        try:
            path = os.path.realpath(project)
            if "IsProjectOwner" in self.mydict.keys():
                if Path(path).joinpath(f'.is{owner}db').exists():
                    Path(path).joinpath(f'.is{owner}db').unlink()
                    return True
        except Exception as e:
            pass
        return False


    def Connect(self, project, timeout = '30', pollinterval = '5', mmfromtooldb = None, tmpfromprefs = None, owner = None):
        try:
            normalized_project_path = os.path.realpath(project)
            self.lg.Print("******Python->MongoMon********") 
            self.lg.Print("Connecting project: ", normalized_project_path)

            pinfo = get_process_info()
            user = pinfo["username"]
            host = pinfo["host"]
            pproc = pinfo["pname"]
            
            release  =os.environ["STROOT"] + "/tcad/" + os.environ["STRELEASE"]
            mongodBin = release + "/linux64/bin/mongod"
            
            if os.getenv('SWB_MONGO_MON'): 
                mongomonBin = os.environ['SWB_MONGO_MON']
            elif not mmfromtooldb is None:
                mongomonBin = mmfromtooldb
            else:
                mongomonBin = "swbmongomon"
                        
            self.cacheName  = self.__adjustedPrjPath(normalized_project_path)
            
            tmpPrj = MongoUtil.GetBaseMongoDir(tmpfromprefs) + self.cacheName        
             
            params ={"-user": user,
                     "-project": normalized_project_path,
                     "-timeout": timeout,
                     "-pollinterval": pollinterval,
                     "-mongodb": mongodBin,
                     "-mongomonbin": mongomonBin,
                     "-parentprocessname": pproc,
                     "-parenthost": host,
                     "-tmpdir": tmpPrj
                     }
    
            try:
                self.lg.Print("Attempt direct connection")
                if MongoDB().ConnectDB(self.cacheName, tmpPrj, 0):
                    if MongoDB().Connection(self.cacheName).Auth(user):
                        self.lg.Print("... success, no swbmongomon launch")
                        self.mydict["parentproject"] = normalized_project_path
                        self.__add(self.cacheName)
                        self._SetOwner(normalized_project_path, owner)
                        return ""
            except Exception as e:
                self.lg.Print(f"... fail, now launching swbmongomon.")

            if self.__launch(params):
                self.mydict["parentproject"] = normalized_project_path
                if MongoDB().ConnectDB(self.cacheName, tmpPrj):
                    if not MongoDB().Connection(self.cacheName).Auth(user):
                        return "Database authentication failure"
                else:
                    return "Database connection failure"
            else:
                self.lg.Print("Launch failure, params:")
                for k, val in params.items():
                    self.lg.Print(f".... {k} :: {val}")
                return "NoDB"
            
            self.__add(self.cacheName)
            self._SetOwner(normalized_project_path, owner)
            return ""
            
        except Exception as e:
            self.lg.Print(f"mongomon.py -> Exception: {e}")
        
        return "Exception in launching swbmongomon infra-structure"

    def Connection(self, project):
        cacheName  = self.__adjustedPrjPath(project)
        return MongoDB().Connection(cacheName)
               
    def Disconnect(self, project = None):
        
        self.lg.Print(f"Disconnect called for project {project}")
        if project:
            cacheName = self.__adjustedPrjPath(project)
        else:
            cacheName = self.cacheName
        
        if cacheName not in self.projects.keys():
            self.lg.Print(f"Disconnect cacheName {cacheName} not found in connections list") 
            return False

        self.lg.Print(f"Disconnect cacheName is {cacheName}")    
        ret = MongoDB().DisconnectDB(cacheName)
         
        if ret:
            dd = self.projects[cacheName]
            
            needsCleaned = bool('IsUsingTemp' not in dd ) 
            self.lg.Print(f"Disconnect needsCleaned is {needsCleaned}")
            if needsCleaned and '-tmpdir' in dd:
                cache = dd['-tmpdir']
                if os.path.exists(cache):
                    self.lg.Print('Removing cache: ', cache)
                    shutil.rmtree(cache)
        else:
            self.lg.Print(f"Disconnect cacheName did not drop ret = {ret}")        
        
        return ret
    
    def Browser(self, project, choice):
        try:
            if choice == 'dbviewer':
                # TKInter in the browser is incompatible with SNPS python
                # so we need to spawn to python 3 as the following would hang
                #from mongobrowser import SWBMongoBrowser
                #SWBMongoBrowser()
                #python = os.environ['STROOT'] + '/tcad/' + os.environ['STRELEASE'] + '/linux64/bin/python3'
                #self.__launchBinary(python, " -c 'from mongobrowser import SWBMongoBrowser; SWBMongoBrowser()'", False)
                raise Exception("DB Viewer is not supported.")
            else:
                cacheName = self.__adjustedPrjPath(project)
                self.__setUp(self.projects[cacheName])
                if choice == 'web':
                    cmdline = self.host + ":" + self.port
                    if cmdline is not None:             
                        self.__launchBinary("firefox", cmdline, False)
                elif choice == 'log':
                    self.__launchBinary("gedit ", self.mydict["-logfile"], False)
                else:
                    self.__launchBinary("gedit ", self.activeconf, False)
            return True
        except Exception as e:
            self.lg.Print(f"mongomon.py -> Exception: {e}")
        return False
    
    
    def IsConnected(self, path):
        #not reliable in it's present form
        if not os.path.exists (f"{path}/.projectdata/db/diagnostic.data"):
            return False
        if os.listdir(f"{path}/.projectdata/db/diagnostic.data"):
            if os.path.exists(f"{path}/.projectdata/mongomon.conf"):                
                return True
            else:
                return False
        else:
            return False
    
    def __SendCommandToMongoMon(self, cmd):
        if hasattr(self, 'host') and hasattr(self, 'port'):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as mongoMonSocket:
                    mongoMonSocket.connect((self.host, int(self.port) ))
                    command = f'CMD {cmd}'.encode('ascii')
                    mongoMonSocket.sendall(command)
                    response = mongoMonSocket.recv(1024)
                    return repr(response)
            except:
                pass
       
        
    def ShutDownMongoMon(self):
        try:
            #disconnect from MongoDB && clean project
            self.Disconnect()

            # signal to close mongod/mongomon pair
            ret = False
            tries = 0
            response = self.__SendCommandToMongoMon("SHUTDOWN")
            while(response != None and tries < 10):
                if(response == "b'OK'"):
                    ret = True

                tries = tries  + 1
                time.sleep(1)
                response = self.__SendCommandToMongoMon("SHUTDOWN")

            delattr(self, 'host')
            delattr(self, 'port')
            return bool (ret and tries > 0)

        except Exception as e:
            self.lg.Print(f"mongomon.py -> ShutDownMongoMon Exception: {e}")
            pass
        return False

    def ProjectDD(self, project):
        cachename = self.__adjustedPrjPath(project)
        return self.projects[cachename]
