# ==================================================================
# SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work  
# of Synopsys, Inc., and is fully protected under copyright and     
# trade secret laws. You may not view, use, disclose, copy, or      
# distribute this file or any information contained herein except   
# pursuant to a valid written license from Synopsys.                
# ==================================================================
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure
from pymongo.database import Database
from pymongo import ASCENDING
from pymongo import DESCENDING
import os

from time import sleep
from swbutils.model.Singleton import singleton
from swbutils.mongo.mongologger import MongoLogger

@singleton
class MongoDB():
    pass

    lg = None
    projects = {}

    def __init__(self):
        self.lg = MongoLogger()
        self.lg.Print("Initiating singleton MongoDB")
        
    def ConnectDB(self, cachename, project, tries = 10):
        if not cachename in self.projects:
            myprj = __project__()
            if myprj.ConnectDB(project, tries):
                #self.lg.Print(f'Recording cache {cachename}')
                self.projects[cachename] = myprj
            else:
                return False        
        return True
    
    def Connection(self, cachename):
        self.lg.Print(f'Connecting to cache {cachename}')
        if cachename in self.projects:
            #self.lg.Print(f'Connecting to existing from cache {cachename}')
            return self.projects[cachename]
        else:
            self.lg.Print(f'No db connection exists for {cachename}')
        return None
        
    def DisconnectDB(self, cachename):
        if cachename in self.projects:
            ret = self.projects[cachename].DisconnectDB()
            del self.projects[cachename]
            return ret
        else:
            self.lg.Print(f'No db connection exists to drop for {cachename}')
        return False                
class __project__():
    
    lg = None
    parentproject = None
    project = None
    client = None
    
    def __init__(self):
        self.lg = MongoLogger()
        self.client = None
    
        
    def __getConfig(self):
        ret = {}
        file1 = open(self.conf , "r")
        
        #build arg dictionary
        for line in file1:
            line = line.strip()
            arg = line.split(" ")
            if len(arg) > 1 :
                ret[arg[0]] = arg[1]
            elif len(arg) > 0:
                ret[arg[0]] = ""
                
    
        #close file
        file1.close
        return ret
    
    def ConnectDB(self, project, tries = 10):
        try:
            self.DisconnectDB()
            self.lg.Print("******Python->MongoD********") 
            #self.lg.Print("Connecting to ", project)
            self.project = project
            self.conf = project + "/.projectdata/mongomon.conf"
            
            while(not os.path.exists(self.conf) and tries > 0):
                self.lg.Print('Awaiting conf')
                sleep(1)
                tries -= 1
                
            if(os.path.exists(self.conf)):
                self.tokens = self.__getConfig()    
                self.parentproject = self.tokens["-project"]
                host = self.tokens["-parenthost"]
                port = self.tokens["-mongodport"]

                self.client = MongoClient(host, int(port), serverSelectionTimeoutMS = 10000, connect = True)
                self.client.admin.command('ismaster')
            
                self.url =  host + ':' + port
                self.lg.Print("Connected Mongod is on: ", self.url)
                return True
            else:
                raise Exception("mongodb.py -> Cannot attempt connect, no config file")
                   
        except ConnectionFailure:
            self.lg.Print("mongodb.py -> Server not available")    
 
        except Exception as ex:
            self.lg.Print(f"mongodb.py -> Connect Exception: {ex}")
            
        self.lg.Print("mongodb.py -> returning False")
        return False
    
    def DisconnectDB(self):
        try:
            if self.client is not None:
                self.lg.Print("******Python->MongoD********") 
                self.lg.Print("Disconnect DB on ", self.url)
                self.client.close()
                self.client = None
                self.lg.Print(".......................")
                self.lg.Print("")
                return True
        except Exception as ex:
            self.lg.Print("mongodb.py -> Disconnect Exception: ", ex)     
        return False
    
    def Auth(self, user):
        
        if self.client is not None:
            db = Database(self.client, 'admin')       
            tries = 10
            while(tries > 0):
                try:
                    db.authenticate(user, user, None, 'SCRAM-SHA-1')
                    self.lg.Print("Authed user: ", user)
                    self.lg.Print("")
                    return True
                except Exception:
                    pass
                
                sleep(0.25)
                tries -= 1
            
        self.lg.Print("Could not Auth user: ", user)   
        return False
    
    #CRUD Operations
    def Create(self, dbname, cname, q  = None, many = False):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        if col is None:
            db.create_collection(cname)
        if not q is None :
            if many:
                return col.insert_many(q)
            else:
                return col.insert_one(q)
        
        return col
    
    # return a list of collections
    # or a list of dictionaries representing the docs
    def Read(self, dbname, cname = None, q = None, f = None, sort_field = "_id", sort_ascending = True):
        db = Database(self.client, dbname)
        if cname is None:
            cur = db.collection_names()
            return cur
        else:
            rows = []
            col = db.get_collection(cname)
            if sort_field is not None and sort_field != "":
                if sort_ascending:
                    direction = ASCENDING
                else:
                    direction = DESCENDING
                cur = col.find(q, f).sort(sort_field, direction)
            else:
                cur = col.find(q, f)
            for doc in cur:
                rows.append(doc)

            return rows
                
        return None
    
    def ReadViaString(self, dbname, cname, q = "{}"):
        dd = literal_eval(q)
        return self.Read(dbname, cname, dd)
    
    def FindAndReplace(self, dbname, cname, field, search, replacement):
        db = Database(self.client, dbname)
        db.eval ("""db.{cname}.find({{}}).forEach(function(doc)
            {
              doc.{field} = doc.{field}.replace('{search}','{replacement}');
              db.{cname}.save(doc);  
            }), {search}, {replacement}
        """)
 
    def Update(self, dbname, cname, q, u, many = False, raw = False, upsert = True):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        
        if '$set' not in u and not raw:
            uset = {'$set' : u}
        else:
            uset = u
        
        if many:
            return col.update_many( q,  uset, upsert) 
        else:
            return col.update_one( q,  uset, upsert)

    def Rename(self, dbname, cname, newname):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        col_exists = cname in db.list_collection_names()
        if col_exists:
            col.rename(newname)

    def Remove(self, dbname, cname):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        col_exists = cname in db.list_collection_names()
        if col_exists:
            col.drop()

    def RemoveDB(self, dbname):
        #db can only be reoved with Root permission, we don't want to expose this to the clients
        # only mongomon has root. So therefore clients need handle Auth and roles for any db's 
        # they want to set up. For our needs we can just empty the collections
        try:
            self.client.drop_database(dbname)
            return True
        except:
            self.lg.Print ("Could not drop DB, now attemping to remove collections")
        try:
            db = Database(self.client, dbname)
            for cname in db.list_collection_names():
                col = db.get_collection(cname) 
                col.drop()
            return True
        except:
            self.lg.Print ("Could not drop DB collections")
            return False

    def CountDocs(self, dbname, cname):
        db = Database(self.client, dbname)
        count = 0
        col = db.get_collection(cname)
        col_exists = cname in db.list_collection_names()
        if col_exists:
            count = col.count_documents({})
        return count

    def Restore(self, dbname, cname):
        db = Database(self.client, dbname)
        cname_bak = cname + '_bak'
        try:
            bcol_exists =  cname_bak in db.list_collection_names()
            if bcol_exists:
                bcol = db.get_collection(cname_bak)
                col_exists = cname in db.list_collection_names()
                if col_exists:
                    col = db.get_collection(cname)
                    self.lg.Print(f'.. removing collection {cname}')
                    col.drop()
                    col = None

                self.lg.Print(f'.. reverting to back up {cname_bak}')
                bcol.rename(cname)
        except Exception as ex:
            self.lg.Print ("Exception Restore: ", ex)
    
    def Delete(self, dbname, cname, q = None, many = False):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        if q is not None:
            if many:
                return col.delete_many(q)
            else:
                return col.delete_one(q)
        else:
            return db.drop_collection(col)
    
    def CreateIndex(self, dbname, cname, index_fields):
        db = Database(self.client, dbname)
        col = db.get_collection(cname)
        col.create_index(index_fields)      


        