"""Unit test for swbutils.scheduler."""


from pathlib import Path
from re import finditer
from shutil import which
from time import sleep


from hypothesis import given  # type: ignore

from hypothesis.strategies import (  # type: ignore
    builds,
    from_regex,
    sampled_from,
)

from pytest import (  # type: ignore  # noqa: PT013
    fixture,
    mark,
)


from ..scheduler import (
    _other_params,
    Scheduler,
    SWBRunEngine,
)


lsf_only = mark.skipif(which("bsub") is None, reason="requires LSF")
sge_only = mark.skipif(which("qsub") is None, reason="requires SGE")

dask_jobqueue_based_schedulers = [
    Scheduler.LSF,
    Scheduler.SGE,
    Scheduler.SLURM,
]

rayuela_supported_schedulers = [Scheduler.LOCAL, *dask_jobqueue_based_schedulers]


@sge_only
def test_sge_out_file():
    """Test that outputFile param works correctly in SWBRunEngine."""
    run_engine = SWBRunEngine()
    scheduler = run_engine.add_scheduler("sge")
    stdout = Path.cwd() / "test.txt"

    job_id = run_engine.submit_job(
        scheduler,
        command='echo "Hello World!"',
        outputFile=stdout,
        reqs="-P bnormal",
    )

    while True:
        sleep(1)

        if run_engine.poll_job(job_id) == "completed":
            break

    with stdout.open() as f:
        assert f.readline().strip() == "Hello World!"

    stdout.unlink()


@lsf_only
def test_lsf_smoke():
    """Smoke test for LSF infrastructure."""
    run_engine = SWBRunEngine()
    scheduler = run_engine.add_scheduler("lsf")
    stdout = Path.cwd() / "test.txt"

    job_id = run_engine.submit_job(
        scheduler,
        command='echo "Hello World!"',
        outputFile=stdout,
        reqs="-q bnormal",
    )

    while True:
        sleep(1)

        if run_engine.poll_job(job_id) == "completed":
            break

    with stdout.open() as f:
        assert f.readline().strip() == "Hello World!"

    stdout.unlink()


def test_local_smoke():
    """Smoke test for local infrastructure."""
    run_engine = SWBRunEngine()
    scheduler = run_engine.add_scheduler("local")
    stdout = Path.cwd() / "test.txt"

    job_id = run_engine.submit_job(
        scheduler, command='echo "Hello World!"', outputFile=stdout
    )

    while True:
        sleep(1)

        if run_engine.poll_job(job_id) == "completed":
            break

    with stdout.open() as f:
        assert f.readline().strip() == "Hello World!"

    stdout.unlink()


def test_lsf_n_option_removal():
    """Assert the -n option is removed from job_extra_directives parameters.

    This is not specific for -n, all handled parameters should be
    removed from job_extra_directives to avoid duplicated information.
    """
    run_engine = SWBRunEngine()
    params = run_engine._parse_rayuela_lsf_params("-n 3")
    assert "job_extra_directives" not in params["infra_args"]


def test_lsf_n_option_is_parsed_into_ncpus():
    """LSF -n option should be moved to ncups."""
    run_engine = SWBRunEngine()
    params = run_engine._parse_rayuela_lsf_params("-n 3")
    assert params["infra_args"]["ncpus"] == 3


# @given(
#     integers(min_value=1),  # noqa: E800
#     sampled_from(
#         ["KB", "K", "MB", "M", "GB", "G", "TB", "T", "PB", "P", "EB", "E", "ZB", "Z"]  # noqa: E800, E501
#     ),
# )  # noqa: E800
# def test_lsf_m_option_parsing(number, unit):
#     """Tests that LSF's -M is parsed correctly."""
#     run_engine = SWBRunEngine()  # noqa: E800
#     params = run_engine._parse_rayuela_lsf_params(f"-M {number}{unit}")  # noqa: E800

#     assert params == {
#         "infra_name": "lsf",  # noqa: E800
#         "infra_args": {"mem": number, "lsf_units": unit},  # noqa: E800
#     }  # noqa: E800


@given(sampled_from(dask_jobqueue_based_schedulers))
def test_empty_requirements(scheduler):
    """Test the result of parsing empty requirements."""
    run_engine = SWBRunEngine()
    params = run_engine._parse_rayuela_parameters(scheduler, "", "a_python_interpreter")

    assert params == {
        "infra_name": scheduler.value,
        "infra_args": {"python": "a_python_interpreter"},
    }


@fixture
def run_engine():
    """Return an instance of :class:`SWBRunEngine`."""
    return SWBRunEngine()


@mark.parametrize(
    "requirements,params",
    [
        (
            "-V -now y -cwd -P bnormal -q bnormal -N jobname",
            {
                "infra_name": "sge",
                "infra_args": {
                    "job_extra_directives": ["-V", "-cwd"],
                    "name": "jobname",
                    "project": "bnormal",
                    "queue": "bnormal",
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-notify  -V -cwd -now n -P bnormal -pe mt 4 "
            "-l health=1,os_distribution=centos|redhat,qsc=!j,qsc=s "
            "-o /remote/ch10tcad1/framework/vryvkin/STDB/SimpleMOS/n73_des.job "
            "-e /remote/ch10tcad1/framework/vryvkin/STDB/SimpleMOS/n73_sge.err "
            '-N "x1888415134718" ',
            {
                "infra_name": "sge",
                "infra_args": {
                    "job_extra_directives": [
                        "-V",
                        "-cwd",
                        "-pe mt 4",
                        (
                            "-o "
                            "/remote/ch10tcad1/framework/vryvkin/STDB/SimpleMOS/"
                            "n73_des.job"
                        ),
                        (
                            "-e "
                            "/remote/ch10tcad1/framework/vryvkin/STDB/SimpleMOS/"
                            "n73_sge.err"
                        ),
                    ],
                    "name": "x1888415134718",
                    "project": "bnormal",
                    "resource_spec": (
                        "health=1,os_distribution=centos|redhat,qsc=!j,qsc=s"
                    ),
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-l health=1 -l os_distribution=centos|redhat -l qsc=!j -l qsc=s ",
            {
                "infra_name": "sge",
                "infra_args": {
                    "resource_spec": (
                        "health=1,os_distribution=centos|redhat,qsc=!j,qsc=s"
                    ),
                    "python": "a_python_interpreter",
                },
            },
        ),
    ],
)
def test_rayuela_sge_param_parsing(requirements, params, run_engine: SWBRunEngine):
    """Test the parsing of SGE parameters in Rayuela."""
    assert (
        run_engine._parse_rayuela_sge_params(requirements, "a_python_interpreter")
        == params
    )


@mark.parametrize(
    "requirements,params",
    [
        # (  # noqa: E800
        #     '-q bnormal -n 4 -M 3GB -J jobname -R "rusage[mem=1000]"',  # noqa: E800
        #     {  # noqa: E800
        #         "infra_name": "lsf",  # noqa: E800
        #         "infra_args": {  # noqa: E800
        #             "job_extra_directives": ['-R "rusage[mem=1000]"'],  # noqa: E800
        #             "lsf_units": "GB",  # noqa: E800
        #             "mem": 3,  # noqa: E800
        #             "name": "jobname",  # noqa: E800
        #             "ncpus": 4,  # noqa: E800
        #             "queue": "bnormal",  # noqa: E800
        #         },
        #     },
        # ),
        (
            '-q bnormal -R "rusage[mem=1000]" -q bhigh -n 32 -R "span[block=32]" -J '
            '"x1652515949575-emw" -q mybnormal',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "job_extra_directives": ['-R "rusage[mem=1000]"', '-R "span[block=32]"'],
                    "name": "x1652515949575-emw",
                    "queue": "mybnormal",
                    "ncpus": 32,
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-n 32 -n 3 -n 4",
            {
                "infra_name": "lsf",
                "infra_args": {"ncpus": 32, "python": "a_python_interpreter"},
            },
        ),
        (
            "-q batch "
            '-R "select[type==X64LIN && osrel>=70 && ui=tcad_swb && mem > 500 ] '
            'span[hosts=1]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": [
                        "-R "
                        '"select[type==X64LIN '
                        "&& osrel>=70 && ui=tcad_swb && mem > 500 ] "
                        'span[hosts=1]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-q batch "
            '-R "select[type==X64LIN && osrel==70 && ui=tcad_tool] '
            'rusage[mem=2000:duration=2]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": [
                        '-R "select[type==X64LIN && osrel==70 && ui=tcad_tool] '
                        'rusage[mem=2000:duration=2]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-q batch "
            '-R "select[type==X64LIN && osrel==70 && ui=tcad_tool] '
            'rusage[mem=16000:duration=2]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": [
                        '-R "select[type==X64LIN && osrel==70 && ui=tcad_tool] '
                        'rusage[mem=16000:duration=2]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-q batch "
            '-R "select[type==X64LIN && osrel==70 && ui=tcad_tool] '
            'rusage[mem=256000:duration=2]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": [
                        "-R "
                        '"select[type==X64LIN && osrel==70 && ui=tcad_tool] '
                        'rusage[mem=256000:duration=2]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            "-q batch "
            "-R "
            '"select[type==X64LIN && osrel==70 && ui=tcad_swb] '
            'rusage[mem=8000:duration=2]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": [
                        "-R "
                        '"select[type==X64LIN && osrel==70 && ui=tcad_swb] '
                        'rusage[mem=8000:duration=2]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            '-q batch -n 4 -R "select[type==X64LIN && osrel==70 && ui=svisual]"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "ncpus": 4,
                    "job_extra_directives": [
                        '-R "select[type==X64LIN && osrel==70 && ui=svisual]"'
                    ],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            '-R "type==X64LIN && osrel>=60 && mem > 4000"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "job_extra_directives": ['-R "type==X64LIN && osrel>=60 && mem > 4000"'],
                    "python": "a_python_interpreter",
                },
            },
        ),
        (
            '-q batch -R "type==X64LIN && osrel==70"',
            {
                "infra_name": "lsf",
                "infra_args": {
                    "queue": "batch",
                    "job_extra_directives": ['-R "type==X64LIN && osrel==70"'],
                    "python": "a_python_interpreter",
                },
            },
        ),
    ],
)
def test_rayuela_lsf_param_parsing(requirements, params, run_engine: SWBRunEngine):
    """Test the parsing of LSF parameters in Rayuela."""
    assert (
        run_engine._parse_rayuela_lsf_params(requirements, "a_python_interpreter")
        == params
    )


def test_rayuela_lsf_produces_scripts_with_only_one_span(run_engine: SWBRunEngine):
    """Test there is only one span statement in the res req string.

    See https://github.com/dask/dask-jobqueue/issues/226 and
    https://github.com/dask/dask-jobqueue/issues/172.

    Rayuela was producing the following job script:

    .. code-block:: bash

        #!/usr/bin/env bash

        #BSUB -J dask-worker
        #BSUB -e /.../.tmp22to2ckj/name-%J.err
        #BSUB -o /.../.tmp22to2ckj/name-%J.out
        #BSUB -q bnormal
        #BSUB -n 4
        #BSUB -R "span[hosts=1]"
        #BSUB -M 1000000
        #BSUB -R "rusage[mem=1000]"
        #BSUB -R "span[hosts=1]"

        /.../gpythonsh -m distributed.cli.dask_worker tcp://10.15.116.180:33345 \
            --nthreads 1 --memory-limit 1000.00MB --name name --nanny --death-timeout \
            60 --local-directory /.../.tmp3

    Adapter code looked as follows (Note the API has changed a lot. I
    had to adapt this test):

    .. code-block:: python

        print(
            engine._show_job_script(
                Scheduler.LSF,
                '-q bnormal -R "rusage[mem=1000]" -n 4 -R "span[hosts=1]" '
                '-J "x7693428377283-sdevice"'
            )
        )


    LSF was throwing the following error:

        Syntax Error: Multiple -R resource requirement strings are not supported on
        "span", "cu" and "affinity" sections. Specify multiple -R resource requirement
        strings only on order, same, rusage, and select sections.
        Bad resource requirement syntax. Job not submitted.
    """
    kwargs = run_engine._parse_rayuela_lsf_params('-R "span[hosts=1]" -n 4')
    job_script = run_engine._job_script(**kwargs)
    assert sum(1 for _ in finditer(r"-R.*span", job_script)) == 1


@given(
    scheduler=sampled_from(dask_jobqueue_based_schedulers),
    log_directory=from_regex(r"(/?.+/?)+", fullmatch=True),
    run_engine=builds(SWBRunEngine),
)
def test_log_directory(scheduler, log_directory, run_engine):
    """Test parse functions propagate "log_directory"."""
    params = run_engine._parse_rayuela_parameters(
        scheduler, "", log_directory=log_directory
    )

    assert params["infra_args"]["log_directory"] == log_directory


@given(
    scheduler=sampled_from(dask_jobqueue_based_schedulers),
    remote_python_interpreter=from_regex(r"(/?.+/?)+", fullmatch=True),
    run_engine=builds(SWBRunEngine),
)
def test_remote_python_interpreter(
    scheduler, remote_python_interpreter, run_engine: SWBRunEngine
):
    """Test remote_python_interpreter is passed when requirements are empty."""
    params = run_engine._parse_rayuela_parameters(
        scheduler, "", remote_python_interpreter=remote_python_interpreter
    )

    assert params["infra_args"]["python"] == remote_python_interpreter


@fixture
def local_scheduler_id(run_engine):
    """Return the scheduler id of a local host scheduler."""
    return run_engine.add_scheduler("local")


@fixture
def local_task_key(run_engine, local_scheduler_id):
    """Return a valid local job id from run_engine."""
    return run_engine.submit_job(local_scheduler_id, "echo PLOP!")


def test_freeing_tasks(run_engine, local_task_key):
    """Test that tasks can be freed."""
    run_engine.free_job(local_task_key)
    assert not run_engine.has_engine_references(local_task_key)


@mark.regression
def test_poll_job_does_not_return_none(run_engine, local_task_key):
    """:meth:`swbutils.scheduler.SWBRunEngine.poll_job` returns str.

    :meth:`swbutils.scheduler.SWBRunEngine.poll_job` should always
    return a string.

    This is a regression test for the following bug:

    >>> from swbutils.scheduler import SWBRunEngine  # doctest: +SKIP
    >>> run_engine = SWBRunEngine()  # doctest: +SKIP
    >>> scheduler = run_engine.add_scheduler("local")  # doctest: +SKIP
    >>> job_id = run_engine.submit_job(scheduler, "echo hello")  # doctest: +SKIP
    >>> type(run_engine.poll_job(job_id))  # doctest: +SKIP
    <class 'NoneType'>
    """
    assert run_engine.poll_job(local_task_key) is not None


def test_freeing_tasks_after_polling_complete_job(run_engine, local_task_key):
    """Test that tasks are freed after poll_job() returns "completed"."""
    while run_engine.poll_job(local_task_key) != "completed":
        pass

    assert not run_engine.has_engine_references(local_task_key)


def test_freeing_tasks_after_stop_job(run_engine, local_task_key):
    """Test that tasks are freed after calling stop_job()."""
    run_engine.stop_job(local_task_key)
    assert not run_engine.has_engine_references(local_task_key)


@mark.regression
def test_double_dashes_on_slurm_requirements():
    """Test that double dashes are correctly parsed in SLURM reqs.

    This is a regression test for the following bug:

    >>> from swbutils.scheduler import SWBRunEngine  # doctest: +SKIP
    >>> run_engine = SWBRunEngine()  # doctest: +SKIP
    >>> run_engine._parse_rayuela_slurm_params("--licenses=ladida")  # doctest: +SKIP
    {'infra_name': 'slurm', 'infra_args': {'job_extra_directives': ['-', '-licenses=ladida']}}

    Note that double dashes are separated in the returned list.
    """
    params = SWBRunEngine()._parse_rayuela_slurm_params("--licenses=ladida")
    assert params["infra_args"]["job_extra_directives"] == ["--licenses=ladida"]


@mark.regression
def test_other_parameters_are_passed_through_without_modifications():
    """Test other parameters are passed through without modifications.

    This is a regression test for the following bug:

    >>> from swbutils.scheduler import _other_params
    >>> [*_other_params.parseString("--licenses=lic_snp_sprocess_all@slurmdb:1")]
    ['--licenses=lic _snp_sprocess_all@slurmdb:1']
    """
    param = "--licenses=lic_snp_sprocess_all@slurmdb:1"
    assert [*_other_params.parseString(param)] == [param]


def test_lsf_r_parameter_is_parsed_correctly():
    """Test that the -R parameter is parsed correctly for LSF."""
    params = SWBRunEngine()._parse_rayuela_lsf_params(
        "-q bnormal "
        '-R "rusage[mem=1000]" '
        "-n 4 "
        '-R "span[hosts=1]" '
        '-J "x7693428377283-sdevice"'
    )

    assert {'-R "rusage[mem=1000]"', '-R "span[hosts=1]"'} <= {
        *params["infra_args"]["job_extra_directives"]
    }


def test_accessing_lsf_r_parameter():
    """Test that the -R parameter is parsed correctly for LSF."""
    reqs = '-R "rusage[mem=1000]"'
    parsed = _other_params.parseString(reqs)
    assert parsed["others"][0] == reqs
